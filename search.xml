<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dwango Programming Contest V (A,B,C)]]></title>
    <url>%2F2018%2F11%2F30%2FDwango-Programming-Contest-V%2F</url>
    <content type="text"><![CDATA[800分的题目都做不出.. 官方题解略长..告辞.. 地址 A - Thumbnail水签到。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[105];int main() &#123; scanf("%d", &amp;n); double s = 0; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), s += a[i]; s /= n; int ans = 0; for (int i = 1; i &lt; n; i++) if (fabs(a[ans]-s) &gt; fabs(a[i]-s)) ans = i; printf("%d\n", ans);&#125; B - Sum AND Subarrays题意找 k 个数字使其 and 之和最大 分析按位贪心，如果这位上 1 的个数大于 k，就把这位上是 0 的数字全部删掉，再处理下一位，小于 k 就跳过。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define pw(i) (1ull&lt;&lt;(i))typedef unsigned long long ull;const int N = 1005;int p[N], n, k;vector&lt;ull&gt; a, b;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) &#123; ull tmp = 0; for (int j = i; j &lt;= n; j++) &#123; tmp += p[j]; a.push_back(tmp); &#125; &#125; ull ans = 0; int t = 62; while (t &gt;= 0) &#123; int num = 0; for (auto x : a) if (x&amp;pw(t)) num++; if (num &gt;= k) &#123; ans ^= pw(t); for (auto x : a) if (x&amp;pw(t)) b.push_back(x); a = b; &#125; t--; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C - k-DMC题意给定长为 N 的字符串 S，Q 个询问，每个询问给一个 k，要你找三元组(a,b,c)的个数，要求 S[a]=&#39;D&#39;, S[b]=&#39;M&#39;, S[c] = &#39;C&#39; $c-a &lt; k$ 数据范围 $N \le 1e6, Q \le 75$ 分析看复杂度就知道$O(NQ)$挺合理。 枚举 &#39;C&#39;，这样每个询问变为$O(1)$求区间内 (&#39;D&#39;,&#39;M&#39;) 的对数。 预处理每个数字前面 &#39;D&#39; 的个数和每个数字前面 &#39;M&#39; 的个数，以及每个数字前 (&#39;D&#39;,&#39;M&#39;) 对数，这样就可以做到$O(1)$的区间查询了。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6+5;char s[N];int n, q;ll D[N], M[N], DM[N];int main() &#123; scanf("%d%s", &amp;n, s+1); for (int i = 1; i &lt;= n; i++) &#123; D[i] = D[i-1], M[i] = M[i-1]; DM[i] = DM[i-1]; if (s[i] == 'D') D[i]++; if (s[i] == 'M') M[i]++, DM[i] += D[i]; &#125; scanf("%d", &amp;q); while (q--) &#123; int k; scanf("%d", &amp;k); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (s[i] == 'C') &#123; int j = max(0, i-k); ans += DM[i]-DM[j]-D[j]*(M[i]-M[j]); &#125; &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 55(A-E,G)]]></title>
    <url>%2F2018%2F11%2F29%2FEducational-Codeforces-Round-55%2F</url>
    <content type="text"><![CDATA[一万个人会 G.. 已经记不得多久没写网络流了.. E 题 k=1的话还做做，大于1还没想好.. 这也太复杂了.. 这里的老哥敲题可真快.. 地址 A. Vasya and Book水分类讨论。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, x, y, d; scanf("%d%d%d%d", &amp;n, &amp;x, &amp;y, &amp;d); int ans = 1e9+5; if (x%d == y%d) ans = min(ans, abs(x-y)/d); if (1%d == y%d) ans = min(ans, (y-1)/d+(x-1)/d+1); if (n%d == y%d) ans = min(ans, (n-y)/d+(n-x)/d+1); if (ans == 1e9+5) ans = -1; printf("%d\n", ans); &#125;&#125; B. Vova and Trophies题意一个只包含 &#39;G&#39; &#39;S&#39; 的字符串，问你交换一次任意两个字符后，连续的 &#39;G&#39; 最多有多长 分析枚举 &#39;S&#39;，判断这个&#39;S&#39; 换成 &#39;G&#39; 后加上其两边的总长，稍作讨论。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int l[N], r[N];int n, num;char s[N];int main() &#123; scanf("%d%s", &amp;n, s+1); for (int i = 1; i &lt;= n; i++) if (s[i] == 'G') l[i] = l[i-1]+1, num++; for (int i = n; i &gt;= 1; i--) if (s[i] == 'G') r[i] = r[i+1]+1; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, l[i]); if (s[i] == 'S') &#123; if (num == l[i-1]+r[i+1]) ans = max(ans, l[i-1]+r[i+1]); else ans = max(ans, l[i-1]+r[i+1]+1); &#125; &#125; printf("%d\n", ans);&#125; C. Multi-Subject Competition题意给你每个学生的专攻方向和其技能等级，要求你所选的每个方向的人数都相同。 问你能得到的最大技能等级之和。 分析按专攻方向分类，再分别从大到小排序。 然后分别算出这个专业选 i 人对答案的共献，即max(0, sum of prefix[i])。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;vector&lt;int&gt; v[N];bool cmp1(int a, int b) &#123; return a &gt; b;&#125;ll res[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); v[a].push_back(b); &#125; for (int i = 1; i &lt;= m; i++) sort(v[i].begin(), v[i].end(), cmp1); for (int i = 1; i &lt;= m; i++) &#123; ll tmp = 0; for (int j = 0; j &lt; v[i].size(); j++) &#123; tmp += v[i][j]; if (tmp &lt; 0) break; res[j+1] += tmp; &#125; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, res[i]); cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Maximum Diameter Graph题意给你每个点的度数限制，问你不超过度数限制的情况下如何连边，使得连通图的直径最长。 分析点分为一度和大于一度。可以先判断下连不连通。 大于1度的点一定连成一条直线，然后头尾连俩一度的点，中间随便插即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 505;int n, d[N];vector&lt;int&gt; a, b;vector&lt;pii&gt; res;int main() &#123; int s = 0; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d[i]); if (d[i] == 1) a.push_back(i); else b.push_back(i), s += d[i]-2; &#125; if ((int)a.size()-2 &gt; s) puts("NO"); else &#123; int ans = b.size() + min((int)a.size(),2); printf("YES %d\n", ans-1); if (b.size() == 0) &#123; puts("1 2"); return 0; &#125; for (int i = 0; i &lt; b.size()-1; i++) res.push_back(pii(b[i], b[i+1])); if (a.size() &gt;= 1) res.push_back(pii(b[0], a[0])); if (a.size() &gt;= 2) res.push_back(pii(b[b.size()-1], a[1])); int j = 0; for (int i = 2; i &lt; a.size(); i++) &#123; while (d[b[j]] &lt;= 2) j++; res.push_back(pii(a[i], b[j])); d[b[j]]--; &#125; printf("%d\n", res.size()); for (auto p : res) printf("%d %d\n", p.first, p.second); &#125;&#125; E. Increasing Frequency题意给定一个数字序列。你有一次区间加法的机会，问操作后连续的数字 c 最多是多少个。 分析不同数字分别考虑。然后 DP，对每个位置而言分别有三个状态：操作区间前，操作区间中，操作区间后。从前一个位置转移即可。 (代码写得略烂..写得我自己都有点浑..) 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;int n, c, a[N];int num[N];vector&lt;int&gt; v[N];int dp[N][3];int main() &#123; scanf("%d%d", &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); num[i] = num[i-1]; if (a[i] == c) num[i]++; v[a[i]].push_back(i); &#125; int ans = num[n]; for (int i = 1; i &lt; N; i++) &#123; if (i == c) continue; if (!v[i].size()) continue; dp[0][0] = num[v[i][0]]; dp[0][1] = num[v[i][0]]+1; dp[0][2] = 0; for (int j = 1; j &lt; v[i].size(); j++) &#123; int tmp = num[v[i][j]]-num[v[i][j-1]]; dp[j][0] = dp[j-1][0] + tmp; dp[j][1] = max(dp[j-1][0] + tmp+1, dp[j-1][1]+1); dp[j][2] = max(dp[j-1][2], dp[j-1][1]) + tmp; &#125; int m = v[i].size(); ans = max(ans, dp[m-1][2]+num[n]-num[v[i][m-1]]); ans = max(ans, dp[m-1][0]+num[n]-num[v[i][m-1]]); ans = max(ans, dp[m-1][1]+num[n]-num[v[i][m-1]]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; G. Petya and Graph题意选了边就要选两头的点。问你最终选出的子图边权减点权最大是多少。 分析最大权闭合子图.. 由于是二分图，复杂度不超过 O(n*m) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge &#123; Edge() &#123;&#125; Edge(int a, int b, ll c, ll d) :from(a), to(b), cap(c), flow(d) &#123;&#125; int from, to; ll cap, flow;&#125;;const int N = 2e3+5;const ll INF = 1e18;struct Dinic &#123; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[N]; bool vis[N]; int d[N], cur[N], s, t; void Init() &#123; for (int i = 0; i &lt; N; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, ll cap) &#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int x = edges.size(); G[from].push_back(x - 2); G[to].push_back(x - 1); &#125; bool BFS() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i&lt;G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; ll DFS(int x, ll a) &#123; if (x == t || a == 0) return a; ll flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; &#125; &#125; return flow; &#125; ll MaxFlow(int s, int t) &#123; this-&gt;s = s; this-&gt;t = t; ll flow = 0; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;dinic;int n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int st = N-1, ed = N-2; for (int i = 1; i &lt;= n; i++) &#123; int w; scanf("%d", &amp;w); dinic.AddEdge(i, ed, w); &#125; ll ans = 0; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); dinic.AddEdge(st, n+i, w); dinic.AddEdge(n+i, u, INF); dinic.AddEdge(n+i, v, INF); ans += w; &#125; ans -= dinic.MaxFlow(st, ed); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #522 (Div. 2) (A-E)]]></title>
    <url>%2F2018%2F11%2F20%2FCodeforces-Round-522-Div-2%2F</url>
    <content type="text"><![CDATA[分类讨论场么.. 地址 A. Kitchen Utensils水签到。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n, k, a[105];int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[x]++; &#125; int num = 0; for (int i = 1; i &lt;= 100; i++) num = max(num, ((a[i]-1)/k+1)*k); int ans = 0; for (int i = 1; i &lt;= 100; i++) if (a[i]) ans += num-a[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Personalized Cup先算出行数列数，再竖着填’*&#39;，横着填字符呗。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char s[N], ans[N][N];int main() &#123; scanf("%s", s); int n = strlen(s); int r = (n-1)/20+1; int c = (n-1)/r+1; int m = r*c; for (int i = 0; i &lt; c; i++) &#123; if (m == n) break; for (int j = 0; i &lt; r; j++) &#123; if (m == n) break; ans[j][i] = '*'; m--; &#125; &#125; int x = 0; for (int i = 0; i &lt; r; i++) for (int j = 0; j &lt; c; j++) &#123; if (ans[i][j] == '*') continue; ans[i][j] = s[x++]; &#125; for (int i = 0; i &lt; r; i++) ans[i][c] = '\0'; printf("%d %d\n", r, c); for (int i = 0; i &lt; r; i++) printf("%s\n", ans[i]);&#125; C. Playing Pianodp[i][j] 表示 第 i 位填 j 是否可行，一遍 dp 顺便记录前驱即可。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int n, a[N];int dp[N][6];int cal(int x, int l, int r) &#123; for (int i = l; i &lt;= r; i++) if (dp[x][i]) return i; return 0;&#125;int b[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= 5; i++) dp[1][i] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; if (a[i] &lt; a[i-1]) dp[i][j] = cal(i-1, j+1, 5); else if (a[i] &gt; a[i-1]) dp[i][j] = cal(i-1, 1, j-1); else dp[i][j] = max(cal(i-1, 1, j-1), cal(i-1, j+1, 5)); &#125; &#125; for (int i = 1; i &lt;= 5; i++) if (dp[n][i]) &#123; b[n] = i; break; &#125; if (!b[n]) puts("-1"); else &#123; for (int i = n-1; i &gt;= 1; i--) &#123; b[i] = dp[i+1][b[i+1]]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%d", b[i]); if (i == n) puts(""); else printf(" "); &#125; &#125;&#125; D. Barcelonian Distance借用直线和不借用直线都算一遍，借用直线就是延 x 轴或者 y 轴先走到直线。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;double a, b, c, x1, y1, x2, y2;double ans;double solve(double x3, double y3, double x4, double y4) &#123; return fabs(x3-x1)+fabs(y3-y1)+hypot(fabs(x3-x4), fabs(y3-y4))+fabs(x4-x2)+fabs(y4-y2);&#125;int main() &#123; scanf("%lf%lf%lf%lf%lf%lf%lf", &amp;a, &amp;b, &amp;c, &amp;x1, &amp;y1, &amp;x2, &amp;y2); ans = fabs(x1-x2)+fabs(y1-y2); if (b) ans = min(ans, solve(x1, -(a*x1+c)/b, x2, -(a*x2+c)/b)); if (a) ans = min(ans, solve(-(b*y1+c)/a, y1, -(b*y2+c)/a, y2)); if (a&amp;&amp;b) &#123; ans = min(ans, solve(x1, -(a*x1+c)/b, -(b*y2+c)/a, y2)); ans = min(ans, solve(-(b*y1+c)/a, y1, x2, -(a*x2+c)/b)); &#125; printf("%.10f\n", ans);&#125; E. The Unbearable Lightness of Weights题意给你 n 个物体的重量和 n 个物体，你只能问你朋友一次 (a,b)，朋友会选 b 个物体总重为 a。 问你最多能确定几个物体的重量。 分析如果只有两个重量，就都可以确定。 有三个以上的重量，只能确定一种重量，即全部选同一种重量的物体且其总重的组成方案唯一。 dp[i][j] 表示总重为 i 的 j 个物体的方案数，多重背包即可。 复杂度 1e8 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[105];bool check() &#123; int cnt = 0; for (int i = 1; i &lt;= 100; i++) if (a[i]) cnt++; return cnt &lt;= 2;&#125;int dp[2][10001][101];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[x]++; &#125; if (check()) &#123; int ans = 0; for (int i = 1; i &lt;= 100; i++) ans += a[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; dp[0][0][0] = 1; for (int i = 1; i &lt;= 100; i++) &#123; memcpy(dp[1], dp[0], sizeof(dp[0])); for (int j = 1; j &lt;= a[i]; j++) &#123; for (int k = i*j; k &lt;= 10000; k++) for (int l = j; l &lt;= 100; l++) dp[1][k][l] = min(2, dp[1][k][l]+dp[0][k-i*j][l-j]); &#125; memcpy(dp[0], dp[1], sizeof(dp[0])); &#125; int ans = 0; for (int i = 1; i &lt;= 100; i++) for (int j = 1; j &lt;= a[i]; j++) if (dp[0][i*j][j] == 1) &#123; ans = max(ans, j); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #520 (Div. 2)（A-E）]]></title>
    <url>%2F2018%2F11%2F18%2FCodeforces-Round-520-Div-2%2F</url>
    <content type="text"><![CDATA[感觉数学题略多. F 题解太长了..告辞.. 地址 A. Minimizing the String水签到。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); a[0] = 0, a[n+1] = 1001; int cnt = 1, ans = 0; for (int i = 1; i &lt;= n+1; i++) &#123; if (a[i] == a[i-1]+1) cnt++; else ans = max(ans, cnt-2), cnt = 1; &#125; ans = max(ans, cnt-2); cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Math题意给你一个数字 n，两个操作：乘上任意一个数；开根号（要求是平方数） 问最小能得到的数字是多少，至少几次操作 分析先上唯一分解定理，最小能得到的数字一定是 n 的所有质因子乘积。 最小次数可按每个质因子分开讨论，因为开根号即为质因子个数除以 2，故先把质因子个数加成二的幂再不断除。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;bool notp[N];int prime[N], pnum;void sieve() &#123; memset(notp, 0, sizeof(notp)); notp[0] = notp[1] = 1; pnum = 0; for (int i = 2; i &lt; N; i++) &#123; if (notp[i] == 0) prime[++pnum] = i; for (int j = 1; j &lt;= pnum &amp;&amp; prime[j] * i &lt; N; j++) &#123; notp[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int n;int main() &#123; sieve(); scanf("%d", &amp;n); int m = n; bool f = 0; int ans1 = 1, ans2 = 0, tmp = 0; for (int i = 1; i &lt;= pnum; i++) &#123; if (m % prime[i] == 0) &#123; int cnt = 0; while (m%prime[i] == 0) cnt++, m /= prime[i]; ans1 *= prime[i]; if (tmp &amp;&amp; cnt != tmp) f = 1; tmp = max(tmp, cnt); &#125; &#125; if (ans1 == n) &#123; printf("%d 0\n", ans1); &#125; else &#123; int x = 1; while (x &lt; tmp) x *= 2, ans2++; if (f || x != tmp) ans2++; printf("%d %d\n", ans1, ans2); &#125;&#125; C. Banh-mi题意先给你一个01串，有 q 个区间询问 操作是先在区间内选一个位置，然后把它吃掉，得到那个位置的得分，并且区间内剩余位置的得分全部加上那个位置的得分 每次询问问该区间所能得到的最大的分是多少 分析先吃大的再吃小的最优，由于只有 0 和 1 ，就先吃 1 再吃 0 每个位置对答案的贡献可单独计算，即 1011 可看作 1000：1+1+2+4 = 2^3 100：1+1+2 = 2^2 10：1+1 = 2^1 这是第一组样例，所以很明白了。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;const int MOD = 1e9+7;ll pw2[N];int n, q, sum[N];char s[N];int main() &#123; scanf("%d%d%s", &amp;n, &amp;q, s+1); pw2[0] = 1; for (int i = 1; i &lt;= n; i++) pw2[i] = pw2[i-1]*2%MOD; for (int i = 1; i &lt;= n; i++) pw2[i] = (pw2[i] + pw2[i-1]) % MOD; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i-1] + s[i]-'0'; while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = r-l+1, b = sum[r]-sum[l-1]; ll ans = pw2[a-1]; if (a &gt; b) ans = (ans + MOD - pw2[a-b-1]) % MOD; printf("%lld\n", ans); &#125;&#125; D. Fun with Integers题意绝对值小于 n 的数字（除了0，1，-1），让每个数字与其倍数（除去 -1）连边，边权是两者之商的绝对值，问每条边限走一遍能得到的最大权值和是多少 分析由于每个点度数都是偶数，故存在欧拉回路。所以每个连通分量里的每条边都能访问到。 实际上根据题解的证明（图中每条边都在同一个连通分量内）可以写出 这样 复杂度$O(\sqrt{n})$的代码。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int f[N];ll sum[N];int sf(int x) &#123; return x == f[x] ? x : f[x] = sf(f[x]);&#125;int n;int main() &#123; for (int i = 0; i &lt; N; i++) f[i] = i; scanf("%d", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; for (int j = i+i; j &lt;= n; j += i) &#123; f[sf(i)] = sf(j); sum[i] += 4*(j/i); &#125; &#125; for (int i = 1; i &lt;= n; i++) if (sf(i) != i) sum[sf(i)] += sum[i]; ll ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, sum[sf(i)]); printf("%lld\n", ans);&#125; E. Company题意给定一棵有根树，q 个区间询问。 对于每个询问，要求区间内删去一个点后剩余点的 LCA 的深度，问删哪个点，深度最大多少 分析没记错的话去年多校训练碰到过类似题目。 先对每个点求 DFS 序，由于所有点的 LCA 的 DFS 序的作用域一定是恰好包含所有点的 DFS 序，即这些点的 LCA 即为 DFS 序最小的和最大的两个点的 LCA 。 故删掉的一定是 DFS 序最小的点或者最大的点。 倍增求 LCA + ST 表，复杂度$O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define pw(i) (1&lt;&lt;(i))const int N = 1e5+5;const int LEV = 20;vector&lt;int&gt; G[N];int dph[N], fa[N][LEV];int L[N], dfs_clock, F[N]; // dfs序和逆映射void dfs(int rt, int f) &#123; L[rt] = ++dfs_clock; F[dfs_clock] = rt; for (int i = 1; i &lt; LEV; i++) &#123; if (dph[rt]-1 &lt; pw(i)) break; fa[rt][i] = fa[fa[rt][i-1]][i-1]; &#125; for (int v : G[rt]) &#123; dph[v] = dph[rt]+1; fa[v][0] = rt; dfs(v, rt); &#125;&#125;int lca(int a, int b) &#123; if (dph[a] &lt; dph[b]) swap(a, b); int t = dph[a]-dph[b]; for (int i = 0; i &lt; LEV; i++) if (pw(i)&amp;t) a = fa[a][i]; for (int i = LEV-1; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; if (a != b) return fa[a][0]; return a;&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); memset(fa, 0, sizeof(fa)); dph[1] = 1; dfs_clock = 0;&#125;int Min[N][20], Max[N][20], lg2[N];void Init(int a[], int n) &#123; for (int i = 2; i &lt;= n; i++) lg2[i] = lg2[i/2]+1; for (int i = 1; i &lt;= n; i++) Min[i][0] = Max[i][0] = a[i]; for (int j = 1; j &lt;= lg2[n]; j++) for (int i = 1; i+pw(j)-1 &lt;= n; i++) &#123; Min[i][j] = min(Min[i][j-1], Min[i+pw(j-1)][j-1]); Max[i][j] = max(Max[i][j-1], Max[i+pw(j-1)][j-1]); &#125;9&#125;int Qmin(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return min(Min[l][k], Min[r+1-pw(k)][k]);&#125;int Qmax(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return max(Max[l][k], Max[r+1-pw(k)][k]);&#125;int solve(int l, int a, int r) &#123; if (a == l) return lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); if (a == r) return lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f1 = lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f2 = lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); return lca(f1, f2);&#125;int main() &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); init(n);//multiLCA-init for (int i = 2; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); G[x].push_back(i); &#125; dfs(1, 1); Init(L, n);//ST-init while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = F[Qmin(l, r)], b = F[Qmax(l, r)]; int fa = solve(l, a, r), fb = solve(l, b, r); if (dph[fa] &gt; dph[fb]) printf("%d %d\n", a, dph[fa]-1); else printf("%d %d\n", b, dph[fb]-1); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 54 (A-F)]]></title>
    <url>%2F2018%2F11%2F16%2FEducational-Codeforces-Round-54%2F</url>
    <content type="text"><![CDATA[日常掉分.. D 被无良学弟 hack 了，这个故事告诉我们 CF 上不要写spfa... E 比赛时候觉得挺难的（然后溜了），赛后仔细分析了下觉得还是挺妙的。 F 傻傻分析不清，然而题解分析的贼清楚.. 最后一题日常不会.. 地址 A. Minimizing the String题意删除一个字符使得字典序最小 分析贪心呀，从前往后删第一个 s[i]&gt;s[i-1]。或者最后一个。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;char s[N];int n;int main() &#123; cin &gt;&gt; n &gt;&gt; s; int ans = n-1; for (int i = 0; i &lt; n-1; i++) &#123; if (s[i] &gt; s[i+1]) &#123; ans = i; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == ans) continue; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl;&#125; B. Divisor Subtraction题意给一个数字 n，每次减去其最小质因子，重复此步骤，问共几次减到 0 分析如果 n 是质数，就一次。 如果 n 是偶数，就 n/2。 如果 n 是奇数，最小质因子 d 一定是奇数，故 (n-d)/2+1 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;ll n;ll solve(ll n) &#123; if (n%2 == 0) return n/2; for (ll i = 2; i*i &lt;= n; i++) if (n%i == 0) return 1+(n-i)/2; return 1;&#125;int main() &#123; cin &gt;&gt; n; cout &lt;&lt; solve(n) &lt;&lt; endl;&#125; C. Meme Problem解一元二次方程 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;int t, d;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;d); if (d*d-4*d &lt; 0) puts("N"); else &#123; double a = (d+sqrt(d*d-4*d))/2; double b = (d-sqrt(d*d-4*d))/2; printf("Y %.9f %.9f\n", a, b); &#125; &#125;&#125; D. Edge Deletion题意给你一张图，有边权。问你最多留下哪 k 条边，使得原图和新图中由 1 的最短路长度不变的点留下的最多 分析先建由 1 出发的最短路树，把多余的边全删掉。 还不够的话，从叶子开始删边。（拓扑排序或者别的什么） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const ll INF = 1e18;struct Edge &#123; int v; ll w; int id; bool operator &lt; (const Edge&amp; b) const &#123; return w &gt; b.w; &#125;&#125;;vector&lt;Edge&gt; G[N];void addedge(int u, int v, int w, int id) &#123; G[u].push_back(Edge&#123;v, w, id&#125;);&#125;int pre[N], f[N];ll d[N];bool vis[N];typedef Edge Node;priority_queue&lt;Node&gt; Q;void Dijkstra(int s, int n) &#123; while (!Q.empty()) Q.pop(); for (int i = 0; i &lt;= n; i++) d[i] = INF, vis[i] = 0; d[s] = 0; Q.push(Node&#123;s, 0&#125;); while (!Q.empty()) &#123; Node tmp = Q.top(); Q.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = 1; for (const auto&amp; e : G[u]) &#123; if (!vis[e.v] &amp;&amp; d[e.v] &gt; d[u] + e.w) &#123; d[e.v] = d[u] + e.w; pre[e.v] = e.id; f[e.v] = u; Q.push(Node&#123;e.v, d[e.v]&#125;); &#125; &#125; &#125;&#125;int n, m, k;int cnt[N];bool val[N];queue&lt;int&gt; que;void solve() &#123; for (int i = 2; i &lt;= n; i++) cnt[f[i]]++; for (int i = 1; i &lt;= n; i++) &#123; if (!cnt[i]) que.push(i); &#125; while (!que.empty()) &#123; int v = que.front(); que.pop(); val[pre[v]] = 0; k++; if (k == 0) return; cnt[f[v]]--; if (!cnt[f[v]]) que.push(f[v]); &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; Dijkstra(1, n); for (int i = 2; i &lt;= n; i++) val[pre[i]] = 1; for (int i = 1; i &lt;= m; i++) &#123; if (val[i]) k--; &#125; if (k &lt; 0) solve(); for (int i = 1; i &lt;= m; i++) if (val[i]) ans.push_back(i); printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; E. Vasya and a Tree题意给定一棵树和若干操作。操作 (v,d,x) 是 v 的子树中与 v 距离小于等于 d 的节点权值都加上 x 问所有操作结束后的每个点的权值。 分析操作可离线。建一棵基于深度的线段树（或者树状数组），在 DFS 不断修改和查询。 单次修改相当于 区间 [dps(v), dps(v)+d] 加上 x 。 区间修改单点查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int N = 3e5+5;vector&lt;int&gt; G[N];vector&lt;pii&gt; Q[N];ll c[N];void modify(int x, int num) &#123; while (x &lt; N) c[x] += num, x += x&amp;-x;&#125;ll sum(int x) &#123; ll s = 0; while (x) s += c[x], x -= x&amp;-x; return s;&#125;ll ans[N];int dps[N];void DFS(int u, int pre) &#123; dps[u] = dps[pre]+1; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u], x); modify(dps[u]+d+1, -x); &#125; ans[u] = sum(dps[u]); for (auto v : G[u]) &#123; if (v == pre) continue; DFS(v, u); &#125; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u],-x); modify(dps[u]+d+1, x); &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); G[a].push_back(b); G[b].push_back(a); &#125; int q; scanf("%d", &amp;q); while (q--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); Q[a].push_back(pii(b, c)); &#125; DFS(1, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Summer Practice Report题意魔改题意。有 n 个连续的区间，告诉你每个区间里需要放\(x_i\)个物体 a，(y_i\)个物体 b 问你是否有一种放置方法，能不出现连续 k 个以上的 a 或 b（可跨区间）。 分析设 \(dp[i][0]\) 表示第 i 个区间， 若以 a 物体结尾，末尾最少的 a 物体数量。\(dp[i][1]\)类似。 最后判断 \(dp[n][0]\) 或 \(dp[n][1]\) 是否满足要求即可。 考虑 \(dp[i-1][0]\)转移至\(dp[i][0]\)： ​ 首先要满足 \(x_i \ge \lceil\frac{y_i}{k}\rceil\)，即每 k 个 b 物体后插入一个 a 。 ​ 然后当 \(x_i \le y_i*k+1 - dp[i-1][0] \) 时，某尾 a 的数量始终为 1，即每个 b 前面插满 k 个 a ，包括上一段的。 ​ \(x_i\)还多的话，则最少为 \(x_i-(y_i*k-dp[i-1][0])\)。 可同理考虑\(dp[i-1][1]\)转移至\(dp[i][0]\)，以及\(dp[i][1]\)的转移。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5+5;int n, k;int x[N], y[N];int dp[N][2];int solve1(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y+pre-1)/k+1) return k+1; if (x &lt;= 1ll*y*k) return 1; return x-1ll*y*k;&#125;int solve2(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y-1)/k+1) return k+1; if (x &lt;= 1ll*y*k-pre) return 1; return x-(1ll*y*k-pre);&#125;bool solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = min(solve1(dp[i-1][1], x[i], y[i]), solve2(dp[i-1][0], x[i], y[i])); dp[i][1] = min(solve1(dp[i-1][0], y[i], x[i]), solve2(dp[i-1][1], y[i], x[i])); &#125; return dp[n][0] &lt;= k || dp[n][1] &lt;= k;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;y[i]); if (solve()) puts("YES"); else puts("NO");&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #519 (A-F)]]></title>
    <url>%2F2018%2F11%2F13%2FCodeforces-Round-519-A-F%2F</url>
    <content type="text"><![CDATA[水一把 CF，感觉全暴力而且代码量略少。 G 题不会..打扰了.. 地址 A. Elections公式解即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); int s = 0, k = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; k = max(k, a[i]); &#125; k = max(k, s*2/n+1); printf("%d\n", k);&#125; B. Lost ArrayKMP 的 next 函数求出所有循环节。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int n, a[N], nxt[N];void GetNxt(int s[], int n) &#123; int j = 0, k = -1; nxt[0] = -1; while(j &lt; n) &#123; if (k != -1 &amp;&amp; s[j] != s[k]) k = nxt[k]; else nxt[++j] = ++k; &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = n; i &gt;= 1; i--) a[i] -= a[i-1]; GetNxt(a+1, n); int m = n; while (nxt[m] &gt;= 0) &#123; ans.push_back(n-nxt[m]); m = nxt[m]; &#125; printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; C. Smallest Word题意给定一个只有字符 a,b 的串，问按顺序 reverse 哪几个前缀可以使其字典序最小。 分析转几次就会发现所有的 a 和所有的 b 是可以转到一起的，故先转到一起，最后转到 a 在前 b 在后即可。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;char s[N];bool val[N];int main() &#123; scanf("%s", &amp;s); int n = strlen(s); char now = s[0]; for (int i = 0; i &lt; n; i++) &#123; if (s[i] != now) &#123; val[i-1] = 1; now = s[i]; &#125; &#125; if (now == 'a') val[n-1] = 1; for (int i = 0; i &lt; n; i++) &#123; printf("%d", val[i]); if (i == n-1) puts(""); else printf(" "); &#125;&#125; D. Mysterious Crime题意给定10个排列，问它们的相同子串的个数。 分析由于是排列，故每个数字唯一双射一个位置。 可直接按第一个串的子串找，相当于把第一个串分成好多段，每一段都是一个相同子串，由此计数。 具体分法，即某一段是否在某个位置结束，只用看第一段这个位置和其他串的对应位置是否映射同一个数字。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;int a[11][N], pos[11][N];bool vis[N];bool check(int x, int cnt) &#123; for (int i = 1; i &lt;= m; i++) if (pos[i][x]+cnt &gt; n) return 0; for (int i = 2; i &lt;= m; i++) if (a[i][pos[i][x]+cnt] != a[i-1][pos[i-1][x]+cnt]) return 0; return 1;&#125;int main() &#123; scanf("%d%d",&amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); pos[i][a[i][j]] = j; &#125; if (m == 1) &#123; printf("%lld\n",1ll*n*(n+1)/2); return 0; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; while(check(a[1][i], cnt)) cnt++; ans += 1ll*cnt*(cnt+1)/2; i += cnt-1; &#125; printf("%lld\n", ans);&#125; D - Crossing题意给定 n 个 (x,y) ，两两匹配的贡献是\(min(a_x+b_y,a_y+b_x)\) 然后除掉给定的m对匹配后，问你剩余的两两匹配之和。 分析按 \(a_x+b_y&lt;a_y+b_x\) 即 \(a_x-a_y&lt;b_x-b_y\) 排序后直接算即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;int n, m;struct Node &#123; int x, y, id; bool operator &lt; (const Node b) const &#123; return x-y &lt; b.x-b.y; &#125;&#125;a[N];ll x[N], y[N];ll ans[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); int res = min(a[u].x+a[v].y, a[u].y+a[v].x); ans[u] -= res; ans[v] -= res; &#125; sort(a+1, a+1+n); for (int i = 1; i &lt;= n; i++) x[i] = x[i-1] + a[i].x; for (int i = n; i &gt;= 1; i--) y[i] = y[i+1] + a[i].y; for (int i = 1; i &lt;= n; i++) &#123; ans[a[i].id] += 1ll*a[i].y*(i-1)+x[i-1]; ans[a[i].id] += 1ll*a[i].x*(n-i)+y[i+1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Make It One题意从 n(3e5) 个给定的数字中选一组 gcd 为 1 的数，最少选几个 分析根据唯一分解定理，每选择一个数字至少消去一种素因子，而前 7 个素因子之积已超过 3e5，故至多选7个。 \(dp[i][j]\) 表示 i 的倍数中选出 j 个，且 gcd 为 i 的方案数 ： $$dp[i][j] = \binom{cnt_i}{j}-\sum_{k=2}^{\infty}dp[i*k][j]$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const int MOD = 1e9+7;int F[N], Finv[N], inv[N];void init() &#123; inv[1] = 1; for (int i = 2; i &lt; N; i ++) &#123; inv[i] = (MOD - MOD / i) * 1ll * inv[MOD % i] % MOD; &#125; F[0] = Finv[0] = 1; for (int i = 1; i &lt; N; i ++) &#123; F[i] = F[i-1] * 1ll * i % MOD; Finv[i] = Finv[i-1] * 1ll * inv[i] % MOD; &#125;&#125;int comb(int n, int m) &#123; if (m &lt; 0 || m &gt; n) return 0; return F[n] * 1ll * Finv[n - m] % MOD * Finv[m] % MOD;&#125;int n, cnt[N];ll dp[N][10];int main() &#123; init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt[x]++; &#125; for (int i = 1; i &lt; N; i++) for (int j = i+i; j &lt; N; j += i) cnt[i] += cnt[j]; for (int i = N-1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= 7; j++) &#123; dp[i][j] = comb(cnt[i], j); for (int k = i+i; k &lt; N; k += i) dp[i][j] = (dp[i][j] + MOD - dp[k][j]) % MOD; &#125; &#125; int ans = -1; for (int i = 7; i &gt;= 1; i--) if (dp[1][i]) ans = i; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest (C,D,E)]]></title>
    <url>%2F2018%2F10%2F28%2FTenka1-Programmer-Contest%2F</url>
    <content type="text"><![CDATA[第一把 AtCoder，可以说是真的菜了，E 题调到死都没调出来... 地址 C - Align题意给定 n 个数字，要求排成一排后任意两个数字之差的绝对值之和最大，求最大值 分析一定是将数列排序后分成两半，前一半和后一半交替排列。绝对值符号可以去掉，然后每个数字计算次数只跟其位置有关，最后分类讨论一下就好了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+1+n); if (n%2 == 0) &#123; ll ans = 0; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; ans -= a[n/2]; ans += a[n/2+1]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; ll ans = 0; ans -= a[n/2]; ans -= a[n/2+1]; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; ll ans2 = 0; for (int i = 1; i &lt;= n/2; i++) ans2 -= 2*a[i]; ans2 += a[n/2+2]; ans2 += a[n/2+1]; for (int i = n/2+3; i &lt;= n; i++) ans2 += 2*a[i]; ans = max(ans, ans2); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D - Crossing题意给定 n，问是否存在这样的集合组： 1-n 每个数字都恰好被包含在两个集合中 任意两个集合仅有一个相同数字 分析n 条边的完全图 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n;int check(int n) &#123; for (int i = 1; i*(i-1)/2 &lt;= n; i++) if (i*(i-1)/2 == n) return i; return 0;&#125;int mp[505][505];int main() &#123; scanf("%d", &amp;n); int k = check(n); if (!k) puts("No"); else &#123; puts("Yes"); for (int i = 1; i &lt;= k; i++) for (int j = i+1; j &lt;= k; j++) mp[i][j] = mp[j][i] = n--; printf("%d\n", k); for (int i = 1; i &lt;= k; i++) &#123; printf("%d", k-1); for (int j = 1; j &lt;= k; j++) &#123; if (j == i) continue; printf(" %d", mp[i][j]); &#125; puts(""); &#125; &#125;&#125; E - Equilateral题意给出一张仅含 &#39;#&#39; 和 &#39;*&#39; 的矩阵，问位置三元组的数目，其满足每个位置上的字符都是 &#39;#&#39; 且任意两点的麦哈顿距离相同 分析跟题解大致相同的思路。 中心红点是三点麦哈顿距离的交点。a 和 b 长度相同，第三个点坐落在蓝线上。故先枚举中间的红点，再枚举另外俩红点的位置，统计蓝线上的点的数目即可。预处理斜线前缀和，复杂度O(n^3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 305;int n, m;char mp[3*N][3*N];int suml[3*N][3*N], sumr[3*N][3*N];ll solve(int x, int y) &#123; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; if (mp[x-i][y] == '#') num++; if (mp[x+i][y] == '#') num++; if (mp[x][y-i] == '#') num++; if (mp[x][y+i] == '#') num++; if (num == 3) ans++; else if (num == 4) ans += 4; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x+1, sy = y+i-1; int ex = x+i-1, ey = y+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x+1, sy = y-i+1; int ex = x+i-1, ey = y-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x-i+1, sy = y-1; int ex = x-1, ey = y-i+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x-i+1, sy = y+1; int ex = x-1, ey = y+i-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = N+1; i &lt;= N+n; i++) scanf("%s", mp[i]+1+N); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) suml[i][j] = sumr[i][j] = (mp[i][j] == '#'); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) &#123; sumr[i][j] += sumr[i-1][j-1]; suml[i][j] += suml[i-1][j+1]; &#125; ll ans = 0; for (int i = N+1; i &lt;= N+n; i++) for (int j = N+1; j &lt;= N+m; j++) ans += solve(i, j); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
