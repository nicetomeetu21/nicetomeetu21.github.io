<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Multi-Scale Context Aggregation by Dilated Convolutions]]></title>
    <url>%2F2020%2F02%2F15%2FImage%20Segmentation%2F2016-Multi-Scale-Context-Aggregation-by-Dilated-Convolutions%2F</url>
    <content type="text"><![CDATA[Multi-Scale Context Aggregation by Dilated ConvolutionsResearch ObjectiveThe goal is to compute a discrete or continuous label for each pixel in the image。 Semantic segmentation, which calls for classifying each pixel into one of a given set of categories。 Problem StatementFormer convolutional network architectures purposed for dense prediction were originally been developed for image classification. Therefore, it would be worth exploring about which aspects of the repurposed networks are truly necessary and which reduce accuracy when operated densely. And we need modules designed specifically for dense prediction to improve accuracy further. Method(s)dilated convolutionLet $F$ be a image and $k$ be a convolution filter, $l$-dilated convolution can be formed as$$(F*lk)(p)=\sum{s+lt=p}F(s)k(t)$$ Characteristicdilated convolutions support exponentially expanding receptive fields without losing resolution or coverage. Considerapplying $3\times3$ filters with exponentially increasing dilation:$$F_{i+1}=F_i*_{2^i}k_i$$It is easy to see that the size of the receptive field of each element in $F_{i+1}$ is $(2^{i+2}-1)\times(2^{i+2}-1)$ multi-scale context aggregation moduleThe module takes $C$ feature maps as input and produces $C$ feature maps as output. The input and output have the same form, thus the module can be plugged into existing dense prediction architectures. The basic context module has $7$ layers that apply $3\times3$ convolutions with different dilation factors. The dilations are $1, 1, 2, 4, 8, 16,$ and $1$. Each of these convolutions is followed by a pointwise truncation $max(\cdot; 0)$. A final layer performs $1\times1\times C$ convolutions and produces the output of the module. Note that the frontend module that provides the input to the context network in our experiments produces feature maps at $64\times64$ resolution. We therefore stop the exponential expansion of the receptive field after layer 6. identity initializationAuthors found that random initialization schemes were not effective for the context module. A form of identity initialization was used:$$k^b(t,a)=1_{[t=0]}1_{[a=b]}$$This initialization sets all filters such that each layer simply passes the input directly to the next. Conclusionthe dilated convolution operator is particularly suited to dense prediction due to its ability to expand the receptive field without losing resolution or coverage. the accuracy of existing convolutional networks for semantic segmentation can be increased by removing vestigial components that had been developed for image classification]]></content>
      <categories>
        <category>Image Segmentation</category>
      </categories>
      <tags>
        <tag>Paper Note</tag>
        <tag>ICLR 2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Digital Image Processing [Gonzalez]》 第3章 学习笔记]]></title>
    <url>%2F2020%2F02%2F13%2FImage%20Processing%2F%E3%80%8ADigital-Image-Processing-Gonzalez-%E3%80%8B-%E7%AC%AC3%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[3 Intensity Transformations and Spatial Filtering It makes all the difference whether one sees darkness through the light or brightness through the shadows.——David Lindsay Preview​ Two principal categories of spatial processing are intensity transformations and spatial filtering 3.1 Background​ The spatial domain processes we discuss in this chapter can be denoted by the expression:$$g(x,y)=T[f(x,y)]$$ where $f(x,y)$ is the input image, $g(x,y)$ is the output image, and $T$ is an operator on $f$ defined over a neighborhood of point $(x, y)$. ​ The smallest possible neighborhood is of size $1\times 1$.In this case, $g$ dependsonly on the value of $f$ at a single point $(x, y)$ and $T$ in Eq. (1) becomes anintensity (also called gray-level or mapping) transformation function of the form:$$s=T(r)$$ 3.2 Some Basic Intensity Transformation Functions 3.2.1 Image Negatives$$s=L-1-r$$ 3.2.2 Log Transformations$$s = c log (1 + r)$$ 3.2.3 Power-Law (Gamma) Transformations$$s=cr^\gamma$$ ​ A variety of devices used for image capture, printing, and display respondaccording to a power law. The process used to correct these power-law response phenomena is called gamma correction. ​ Trying to reproduce colors accurately also requires some knowledge of gamma correction because varying the value of gamma changes not only the intensity, but also the ratios of red to green to blue in a color image. ​ In addition to gamma correction, power-law transformations are useful forgeneral-purpose contrast manipulation. 3.2.4 Piecewise-Linear Transformation FunctionsContrast stretching​ Contrast stretching is a process that expands the range of intensity levels in an image so that it spans the full intensity range of the recording medium or display device Intensity-level slicing​ Highlighting a specific range of intensities in an image. Bit-plane slicing​ Pixels are digital numbers composed of bits. Instead of highlighting intensity-level ranges, we could highlight the contribution made to total image appearance by specific bits. ​ Decomposing an image into its bit planes is useful for analyzing the relative importance of each bit in the image. ​ Also, this type of decomposition is useful for image compression. 3.3 Histogram Processing​ The histogram of a digital image with intensity levels in the range $[0,L-1]$ is a discrete function:$$h(r_k)=n_k$$ where $r_k$ is the $k$th intensity value and $n_k$ is the number of pixels in the image with intensity $r_k$. ​ It is common practice to normalize a histogram by dividing each of its components by the total number of pixels in the image. Thus, a normalized histogram is given by$$p(r_k)=r_k/MN$$​ An image with low contrast has a narrow histogram located typicallytoward the middle of the intensity scale. The components of the histogram in the high-contrast image cover a wide range of the intensity scale and that the distribution of pixels is not too far from uniform. 3.3.1 Histogram Equalization​ we focus attention on transformations of the form$$s=T(r)\ ,\ 0\le r\le L-1$$ $T(r)$ is a monotonically increasing function in the interval $0\le r\le L-1$ $0 \le s\le L-1$ for $0\le r\le L-1$ ​ Let $p_r(r)$ and $p_s(s)$ denote the PDFs of $r$ and $s$, respectively. The PDF of the transformed (mapped) variable s can be obtained using the simple formula:$$p_s(s)=p_r(r)|\frac{dr}{ds}|$$​ Let the transformation function be the cumulative distribution function (CDF):$$s=T(r)=(L-1)\int^r_0p_r(w)dw$$​ To find the $p_s(s)$ corresponding to the transformation, we use Eq.(9):$$\frac{ds}{dr} =\frac{dT(r)}{dr}=(L-1)\frac{d}{dr}[\int^r_0p_r(w)dw]=(L-1)p_r(r)$$ $$p_s(s)=p_r(r)|\frac{dr}{ds}|=p_r(r)|\frac{1}{(L-1)p_r(r)}|=\frac{1}{L-1}$$ ​ It is important to note the resulting $p_s(s)$ always is uniform, independently of the form of $p_r(r)$ . The transformation (mapping) $T(r_k)$ in this equation is called a histogram equalization or histogram linearization transformation. 3.3.2 Histogram Matching (Specification)​ The method used to generate a processed image that has a specified histogram is called histogram matching or histogram specification. ​ an image whose intensity levels have a specified probability density function can be obtained from a given image by using the following procedure: Obtain $p_r(r)$ from the input image and use Eq. (10) to obtain the values of $s$. Use the specified PDF to obtain the transformation function $G(z)$. Obtain the inverse transformation $z=G^{-1}(s)$ Obtain the output image by Eq. (10) 3.3.3 Local Histogram Processing​ The procedure is to define a neighborhood and move its center from pixel to pixel. At each location, the histogram of the points in the neighborhood is computed and either a histogram equalization or histogram specification transformation function is obtained. ​ As often is the case with histogram equalization of smooth, noisy regions, this image shows significant enhancement of the noise 3.3.4 Using Histogram Statistics for Image Enhancement​ The mean is a measure of average intensity, the variance (or standard deviation) is a measure of contrast in an image. ​ When working with only the mean and variance, it is common practice to estimate them directly from the sample values, without computing the histogram. 3.4 Fundamentals of Spatial Filtering​ We focus attention first on linear filters and then illustrate somesimple nonlinear filters. ​ There is a one-to-one correspondence between linear spatial filters and filters in the frequency domain. 3.4.2 Spatial Correlation and Convolutioncorrelation$$w(x,y)☆f(x,y)=\sum^a_{s=-a}\sum^b_{t=-b}w(s,t)f(x+s,y+t)$$ convolution$$w(x,y)★f(x,y)=\sum^a_{s=-a}\sum^b_{t=-b}w(s,t)f(x-s,y-t)$$ ​ It should be point out that you are likely to encounter the terms, convolution filter, convolution mask or convolution kernel. As a rule, these terms are used to denote a spatial filter, and not necessarily that the filter will be used for true convolution. 3.4.3 Vector Representation of Linear Filtering$$R=\sum^{mn}_{k=1}w_kz_k=\mathbf{w}^T\mathbf{z}$$ 3.4.4 Generating Spatial Filter Masks​ All we can do with linear filtering is to implement a sum of products. 3.5 Smoothing Spatial Filters​ Smoothing filters are used for blurring and for noise reduction. 3.5.1 Smoothing Linear Filters averaging filters (lowpass filters): linear spatial filter is simply the average of the pixels contained in the neighborhood of the filter mask. box filter: A spatial averaging filter in which all coefficients are equal. weighted average: pixels are multiplied by different coefficients, thus giving more importance (weight) to some pixels at the expense of others. 3.5.2 Order-Statistic (Nonlinear) Filters​ Order-statistic filters are nonlinear spatial filters whose response is based on ordering (ranking) the pixels, and then replacing the value of the center pixel with the value determined by the ranking result. ​ Median filters are particularly effective in the presence of impulse noise. median filter: replaces the value of a pixel by the median of the intensity values in the neighborhood of that pixel impulse noise (salt-and-pepper noise), its appearance as white and black dots superimposed on an image 3.6 Sharpening Spatial Filters​ The principal objective of sharpening is to highlight transitions in intensity. ​ Because averaging is analogous to integration, it is logical to conclude that sharpening can be accomplished by spatial differentiation. ​ Image differentiation enhances edges and other discontinuities (such as noise) and deemphasizes areas with slowly varying intensities. 3.6.1 Foundation​ The second derivative enhances fine detail much better than the first derivative and are much easier to implement than first derivates, so we focus our attention initially on second derivatives. 3.6.2 Using the Second Derivative for Image Sharpening—The Laplacian isotropic filters: response is independent of the direction of the discontinuities in the image. rotation invariant. The simplest isotropic derivative operator is the Laplacian:$$\nabla^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}\=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$ the Laplacian is a linear operator The diagonal directions can be incorporated in the definition of the digital Laplacian by adding two more terms to Eq. (16) implementations of the Laplacian with reverse signs found frequently in practice. The basic way in which we use the Laplacian for image sharpening is$$g(x,y)=f(x,y)+c[\nabla^2f(x,y)]$$ 3.6.3 Unsharp Masking and Highboost Filteringunsharp masking : Blur the original image. Subtract the blurred image from the original (the resulting difference is called the mask.) Add a weighted portion($k$) of the mask back to the original image. When $k=1$, we have unsharp masking, as defined above. When $k&gt;1$, the process is referred to as highboost filtering. Choosing $k&lt;1$, de-emphasizes the contribution of the unsharp mask. 3.6.4 Using First-Order Derivatives for (Nonlinear) Image Sharpening—The GradientFor a function $f(x,y)$, the gradient of $f$ at coordinates $(x, y)$ is defined as the two-dimensional column vector$$\nabla f=grad(f)=\begin{bmatrix} g_x\ g_y \end{bmatrix}=\begin{bmatrix} \frac{\partial f}{\partial x}\ \frac{\partial f}{\partial y} \end{bmatrix}$$ This vector has the important geometrical property that it points in the direction of the greatest rate of change of $f$ at location $(x, y)$. The magnitude (length) of vector $\nabla f$, denoted as $M(x, y)$, where$$M(x,y)=mag(\nabla f)=\sqrt{g_x^2+g_y^2}$$ is the value at $(x, y)$ of the rate of change in the direction of the gradient vector. It is common practice to refer to this image as the gradient image The magnitude of this vector is not linear operators, and the partial derivatives are not rotation invariant, so, in some implementations, it is more suitable computationally to approximate the squares and square root operations by absolute values:$$M(x,y)\approx |g_x|+|g_y|$$ This expression still preserves the relative changes in intensity, but the isotropic property is lost in general 3.8 Using Fuzzy Techniques for Intensity Transformations and Spatial Filtering3.8.2 Principles of Fuzzy Set Theorya fuzzy set is an ordered pair consisting of values of z and a corresponding membership function that assigns a grade of membership to each z.That is$$A={z,\mu_A(z)|z\in Z}$$ all $z$s for which $\mu_A(z)=1$ are full members of the set, all $z$s for which $\mu_A(z)=0$ are not members of the set, and all $z$s for which $\mu_A(z)$ is between 0 and 1 have partial membership in the set 3.8.3 Using Fuzzy Setsdefuzzification: One of the approaches used most frequently is to compute the center of gravity of this set We can use the preceding material to summarize the principal steps followed in the application of rule-based fuzzy logic: Fuzzify the inputs Perform any required fuzzy logical operations Apply an implication method Apply an aggregation method to the fuzzy sets from step 3 Defuzzify the final output fuzzy set]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>《Digital Image Processing [Gonzalez]》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Digital Image Processing [Gonzalez]》 第2章 学习笔记]]></title>
    <url>%2F2018%2F12%2F06%2FImage%20Processing%2F%E3%80%8ADigital-Image-Processing-3rd-Edition-Gonzalez-%E3%80%8B-%E7%AC%AC2%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2 Digital Image Fundamentals Those who wish to succeed must ask the right preliminary questions —— Aristotle Preview本章的第一个目的是向你介绍数字图像处理中的一些基础概念，它们将在本书中沿用。 section 2.1：人类视觉系统的机理，包括人眼成像、光线适应性和辨别能力。 section 2.2：光以及其他电磁波谱的组成部分，它们的成像特性。 section 2.3：图像传感器和它们如何成像。 section 2.4：均匀图像采样和灰度量化的一些概念。 section 2.5：处理了各式各样的像素之间的基本关系。 section 2.6：介绍本书中主要使用的数学工具。 第二个目的是帮助你建立一种 &quot;感觉&quot;，其关于如何使用这些工具去完成各种各样的基础图像处理任务。工具的范围和用法亦将随后文而扩展。 2.1 Elements of Visual Perception虽然数字图像处理是建立在数学和概率公式的基础上，但选择合适的技术仍需要人的直觉和分析，而这些选择通常基于主观的视觉判断上。所以本书选择从建立一个对人类视觉感知的基础的理解开始。 由于篇幅有限不可能讲太细。我们的兴趣主要集中在与人类生成图像并感知相关的机理和参数，以及通过一些因素来学习人类视觉的物理限制，它们也同样用于数字图像的处理。 2.1.1 Structure of the Human Eye 图2.1是一个简化版的人眼横截面图。眼球近似一个球，大约 20 mm 的平均直径。有三层薄膜包围眼球：cornea（眼角膜），sclera （巩膜）外壳，choroid（脉络膜），retina（视网膜）。 cornea 是一种硬而透明的组织，覆盖着眼睛的前表面。与 cornea 相连的是 sclera ，一层不透明的膜覆眼球的剩余区域。 choroid 在 sclera 的正下方，这层膜包含了血管网络，作为滋养眼球的主要来源。choroid 在最前端分为ciliary body（睫状体） 和 iris（虹膜），后者通过收缩和扩张来控制进入眼球光线的数量。 lens（晶状体）由纤维细胞的同心层构成，通过依附于ciliary body 的 ciliary fibers 悬浮。 眼睛最里面的膜是 retina，它布满了整个眼球后部。当人眼适当聚焦，来自外部物体的光线将在其上成像。图像由 retina 上离散的光线接收器提供。接收器主要分两种：cones（锥状体） 和 rods（杆状体）。 cones 的数量在600-700万之间，主要位于视网膜的中间部分 fovea（中央凹），其对颜色高度敏感。人们主要通过它们来分辨图像细节，因为每一个 cones 都连着自己的神经末端。 rods 的数量大约7500-15000万，分布在 retina 表面，它们与彩色视觉无关，而对低照明度敏感。它们用来给出视野内的一般的总体的图像。 图2.2显示了右眼横截面中视神经出现区域的 rods 和 cons 的密度。可以注意到，cons 的密度从 fovea 往外由大变小，而 rods 的密度先变大后变小，距视轴20°左右最大。当然除盲点外。 fovea 本身是一个直径 1.5 mm 的圆形凹槽，为了便于讨论，我们将它视为 $1.5mm * 1.5mm$ 的方形传感器阵列。其上 cons 的密度大约 $150000 mm^2$，即眼球中最敏锐的区域有大约 33700 个。从自然分辨能力上讲，一个 电荷耦合器（charge-coupled device）成像芯片可以有如此多的传感器在$5mm*5mm$的阵列中。 简而言之，眼睛在分辨细节上的基础能力和现在的电子成像传感器相当。 2.1.2 Image Formation in the Eye普通摄影相机中，镜头有固定的焦距聚焦不同的距离是通过变化镜头和成像平面的的距离实现的，成像平面即胶片所在的位置。人眼则相反，镜头和成像区域（retina）的距离是固定的，合适的聚焦距离由改变晶状体（lens）的形状得到。这个操作由睫状体（ciliary body）完成，根据目标距离的远近扁平或加厚晶状体。 2.1.3 Brightness Adaptation and DiscriminationBrightness Adaptation由于数字图像被显示为一个离散的灰度集合。人眼对不同灰度等级的分辨能力在展示图像处理的成果上很重要。人眼视觉系统可接受的光强度的范围很大，从暗示阈值（scotopic threshold）到强光极限（glare limit）。实验数据指出，入射光强度和主观亮度（subjective brightness）是对数函数关系。 图2.4即 光强-主观亮度图。长实线代表了被视觉系统接受的光强度。亮视觉（photopic）范围大约$10^6$。由暗视觉（scotopic）转变为亮视觉的范围大约是 0.001mL 至 0.1mL（millilambert）。 对图中动态范围的解释中，最关键的一点在于视觉系统不能在一个范围中同时工作，即同时只能适应于某一点的光强。它通过改变整体的敏感性来实现这么大范围的适应性改变，即亮度适应现象（brightness adaption）。眼睛可同时辨别的亮度范围较整个适应范围来说很小。对任意给定的条件集，视觉系统的当前感光等级被称为亮度适应等级（brightness adaption level），例如图中点$B_a$。短斜线表示人眼适应于这个亮度等级下时，主观亮度的范围，低于$B_b$的光将成为不可辨别的黑色，斜线上端实际上没有限制，但是更高强度的光会将亮度适应等级提高。 Brightness Discrimination关于人眼在某一个特定适应等级下，对光强的变化的辨别能力，一个著名的实验：对象注视一个足够大的充满视野的均匀发光区，这个区域是典型的漫反射体，使用强度$I$的可变光源从后照射它。在其中心的小圆形范围内增加强度为$\Delta I$的闪光。 如果$\Delta I$不够亮，对象说&quot;no&quot;，最终加到够亮对象会一直说&quot;yes&quot;。分量$\Delta I_c/I$被称为（Weber ratio）,其中$\Delta I_c$是背景为$I$时可辨别照明度增加量的$50\%$。$\Delta I_c/I$越小代表可辨别度越好。 图 2.6 显示，低照明度情况下辨别能力弱，但其随着背景光照增强而迅速增强。两条曲线反映出在低照明度下视觉主要由 rods 提供，而高等级下由 cones 提供。 如果背景光强度固定，且用其他光源代替闪光，将其强度从不能被觉察逐渐变化到始终被察觉，典型的观察者可以观察到 24 次不同的强度变化。粗略地看，这个结果和一个人一张单色图像的任意一点能观察到的不同灰度数量相关。但并不是说一张图象可以被表示为这么点灰度，因为当人眼扫图片时，平均背景发生了变化，故允许在新的适应等级上察觉到不同的强度增量集。最终结果是在整体灰度辩别上眼睛能适应更宽的范围。 summary这两个现象证明被感知的亮度不是简单的关于强度的函数。第一个现象基于一个事实，视觉系统倾向于在不同光强度的边界产生&quot;下冲&quot;或&quot;上冲&quot;现象，如图 2.7。这样带圆齿的带被称为 Mach bands 第二个现象被称为 simultaneous contrast ，基于一个事实，一个区域可观察到的亮度不简单取决于其灰度，如图 2.8。 另一些人类感知现象是视觉错觉，眼睛填充了不存在的信息或错误地赶制了物体的几何特性，如图 2.9。 2.2 Light and the Electromagnetic Spectrum这部分内容与中学相仿。 没有颜色的光被称为 monochromatic light（单色光）或 achromatic light（无色光）。单色光唯一的属性是intensity（强度）或大小。由于单色光的强度反映在感知中是从黑色到灰色，最后变成白色的变化，故单色光的强度通常由 gray level（灰度）来表示。我们将在后续的讨论中交替使用术语 intensity 和 gray level。单色光由黑到白时强度测量值的范围被称为 gray scale，而单色图像通常被成为 gray-scale images。 chromatic light（有色光）跨越电磁波谱的大约 $0.43$ 到 $0.79 \mu m$。除了频率，还有三个基本量用来描述有色光的质量：radiance（发光强度），luminance（光通量），brightness（亮度）。radiance 是光源流出的总能量，通常用 watts（W,瓦特）表示。luminance 由 lumens（lm,流明数）度量，表示对象可感知到的光源发出的总能量。brightness 是一种光感知的主观的描述符，不能测量，它体现了光强度的无色概念，是描述色彩感知的重要因素之一。 理论上，如果一个传感器能检测到某一段电测波谱发出的能量，我们就可以在这个波段上对感兴趣的事件成像。比较重要的一点要指出，若要使一段电磁波 &quot;看&quot; 到物体，其波长必须小于等于目标的尺寸。 2.3 Image Sensing and Acquisition我们感兴趣的多数图像是由一个 &quot;光源&quot; 和 被成像的 &quot;场景&quot;（其具有吸收或反射光源能量的元素）组成。加引号是因为其不一定是每天常见的光源和场景，就比如X光照片。 图像传感器原理很简单：入射光通过特定感知材料与输入的电能相结合，转换成电压。输出的电压波形即传感器的响应，而通过把每个传感器的响应数字化，可得到一个数字量，图像数字化将留到 2.4 节讨论。 2.3.1 Image Acquisition Using a Single Sensor图 2.12(a) 即单个传感器的组件。最常见的这种传感器是光电二极管，其由硅材料制成，输出的电压波形与光强成正比。在传感器的前面使用一个过滤器和提高其光线选择性。 若用这种传感器绘制 2D 图片，就需要给其分别提供在绘制区域上 x 和 y 方向的位移。图 2.13 显示了一个用于高精度扫描的配置。由于机械运动可控精度高，这种廉价而慢速的方法可以得到高精度的图像。另一种配置是在一个平面上，传感器在两个方向上线形移动。这些机械数字化仪有时被称为 microdensitometers（微密度计）。 2.3.2 Image Acquisition Using Sensor Strips将传感器排成一维直线后组成传感器带，这类几何结构比单个传感器使用更加频繁，如图 2.12(b)。该传感器带在一个方向上提供成像单元，在另一个方向上垂直于传感器带移动而成像，如图 2.14(a)。 以圆环形方式安装的传感器带用于医学和工业成像，以得到 3D 物体的横截面图，如图 2.14(b)。需要注意的是，这类传感器的输出必须通过重构算法以获得有意义的横截面图像，换句话说图像不能直接由传感器获取。 2.3.3 Image Acquisition Using Sensor Arrays图 2.12(c) 显示了单独的传感器构成了 2D 的传感器阵列。大量电磁波和超声波装置使用这种构造。这也同样是数字摄像机的主要构造方式。这类传感器的主要用法如图 2.15。 2.3.4 A Simple Image Formation Model在章节 1.1 中，我们定义了一张图片为形如 $f(x,y)$ 的二元方程。在 $(x,y)$ 处的 $f$ 的值是一个正标量，其物理意义由图片源决定。当一张图片由物理过程产生时，其亮度正比于光源射出的能量，因此，$f(x,y)$ 一定非零值，并且有限：$0&lt;f(x,y)&lt;\infty$。 方程 $f(x,y)$ 可以由两部分组成： illumination（反射分量）：入射到场景内的光源照射量，记为 $i(x,y)$，其性质取决于光源。 reflectance（入射分量）：被物体反射的光照量，记为$r(x,y)$，其性质取决于成像物体。 $$f(x,y)=i(x,y)r(x,y), 0&lt;i(x,y)&lt;\infty , 0&lt;r(x,y)&lt;1$$ 这些表达式也同样适用于入射光通过介质成像（胸透X射线），此时用 transmissivity 替代 reflectance。 设一张单色图的某一点 $(x_0,y_0)$ 的灰度为 $\ell = f(x_0,y_0)$，且$L_{min} \le \ell \le L_{max}$。理论上唯一的要求即 $L_{min}$ 是正数，$L_{max}$ 有限。事实上，$L_{min}=i_{min}r_{min}, L_{max}=i_{max}r_{max}$。区间 $[L_{min},L_{max}]$ 即 gray scale。常见情况是将区间在数字上平移至$[0,L-1]$，$\ell = 0$ 代表黑色，$\ell = L-1$ 代表白色。 2.4 Image Sampling and Quantization在上一节的讨论中，我们见到了很多种获得图片的方式，不过我们目标都相同：在感知的数据上产生图片。大多数传感器产生的输出都是连续的电压波形，其振幅与空间特性与感知到的物理特点相关。为了产生数字图像，我们需要将这些连续的感知数据转换至数字形式，这包含两个过程：sampling（采样），quantization（量化）。 2.4.1 Basic Concepts in Sampling and Quantization采样与量化的基本思想如图 2.16。一张图像可能在 x 轴和 y 轴以及振幅上都是连续的。为了将其转化成数字形式，我们需要在其坐标和振幅上分别进行采样，对坐标进行数字化被称为 sampling，对振幅数字化被称为 quantization。 图2.16(c)中白色方块即为对坐标等间隔采样结果，2.16(d)即对振幅量化后的最终数字样本。图中亦可知，量化能达到得精度除了与使用的离散等级得数量相关，也与样本信号得噪声高度相关。 上述采样过程假设了我们有一张在坐标和振幅上都连续的图片，实际上，采样方式由产生图片的传感器的组成决定。当使用单个传感器产生图片时，采样可采用上述过程，具体方式即通过机械位移来使传感器到指定位置采集数据。由于机械运动的高精度，使用这种方式采样可以到达的精度几乎没有限制，但实际上还有其他的干扰因素，比如系统光学原件的数量。 当我们使用 sensing strip 来获得图片，传感器的数目将成为采样精度的限制，虽然我们可以通过机械控制来增加一个方向的精度，但只增加某个方向的精度意义不大。当使用 sensing array 来获得图片时，传感器的个数将成为两个方向的精度限制。 2.4.2 Representing Digital Images假设我们将一张连续图片采样为二维数组 $f(x,y)$，包含 $M$ 行 $N$ 列，为了简便起见，我们使用这些值作为离散坐标：$x=0,1,2,...,M-1$和$y=0,1,2,...,N-1$，即 0-based。这里的坐标并不代表被采样的图片上的物理坐标系，由一张图像的坐标张成的实平面被称为 spatial domain，而 x,y 被称为 spatial variables 或 spatial coordinates。 图 2.18 显示了 3 种基本的显示 f(x,y) 的方法。由于复杂图像包含细节过多，很难用图 2.18(a) 来分析，但处理元素为 (x,y,z)三元组时，这种表示还是很有用。通常图 2.18(b) 和图 2.18(c) 更有用。图 2.18(b) 是一个比较一般的表示方法，而图 2.18(c) 是一个矩阵形式，但由于图片大小的关系，通常很难完全打印。 在公式形式上，我们用 $M*N的数值阵列表示，或是以传统矩阵 A$ 表示。矩阵中的每一个元素被称为 image element, picture element, pixel 或 pel。$$f(x,y)= \begin{pmatrix} f(0,0) &amp; f(0,1) &amp; \cdots &amp; f(0,N-1) \\ f(1,0) &amp; f(1,1) &amp; \cdots &amp; f(1,N-1) \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ f(M-1,0) &amp; f(M-1, 1) &amp; \cdots &amp; f(M-1, N-1) \end{pmatrix} = A = \begin{pmatrix} a_{0,0} &amp; a_{0,1} &amp; \cdots &amp; a_{0,N-1} \\ a_{1,0} &amp; a_{1,1} &amp; \cdots &amp; a_{1,N-1} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{M-1,0} &amp; a_{M-1, 1} &amp; \cdots &amp; a_{M-1, N-1} \end{pmatrix}$$ 简要回顾图 2.18，注意数字图像的原点在左上方，x 轴正方向向下，y 轴正方向下右。这种方便的表示法基于一个事实：很多图片显示装置（TV显示器）扫一张图片时是从左上角开始，从左向右扫的。更重要的事实是按照惯例，矩阵的第一个元素在左上角。 数字化过程需要对 M,N 和 L（离散灰度等级）的取值做出决定。除了必须是正整数，对 M,N 没有更多的限制。然而， 由于对存储容量和量化硬件的考虑，灰度等级通常是 2 的幂：L = 2^k。我们假设离散灰度是等间隔的，它们是处于[0,L-1]中的整数。有时候，gray scale 所跨越的值域被非正式德成为 dynamic range。这一术语在不同领域有不同的用法。在这里，我们定义一个图像系统的 dynamic range 为最大可测量灰度和最小可测量灰度的比值。一般来说其上限取决于saturation（饱和度），下限取决于noise（噪声），如图 2.19。 基本上，动态范围确立了系统能表示的最高和最低灰度，这也同样是图片能具有的。与之紧密相关的一个概念是 image contrast（图像对比度），我们定义它为一张图片最高和最低灰度之差。当一张图片中大量像素具有高动态范围时，我们可以预料图片具有高对比度。我们等第3章再讨论这些细节。 存储一张数字图像需要字节为：$b=M*N*k$。当一张图片有$2^k$个灰度等级时，常见的称法是k-bit image。 2.4.3 Spatial and Intensity Resolution直觉上，spatial resolution 是一张图片中最小可辩别细节的一种度量。在量化上，spatial resolution 可以被表示成好几种方法，其中 line pairs per unit distance 和 dots(pixels) per unit distance 最常用。假设我们用黑白相间的直线带建立一个图，每一条宽 $W units$ ，因此一个 line pair 的宽度为 $2W$， spatial resolution 为 $1/2W$line pairs per unit distance。一个广泛使用的图像分辨率的定义是可分辨的 line pairs per unit distance 的最大数量。在美国，这个测量法通常被表示为 dots per inc (dpi)。空间分辨率的度量必须相对于空间单位来规定才有意义。 intensity resolution 类似定义为灰度等级上的最小可分辨区别。其通常由硬件决定，一般是 2 的幂。不同于 spatial resolution 必须基于单位距离基础才有意义，常见的做法是将量化灰度需要的字节数视为 intensity resolution，因为可分辨的区别不止受 noise 和 saturation 值影响，还与人类的感知能力相关。 Typical effects of varying the number of intensity levels in a digital image. false contouring 由在数字图像的平滑地区中使用的灰度等级不足造成。 一个关于同时改变 N 和 k 对图像造成影响的早期研究：图像集合由图 2.2 的三种图像变化 N 和 k 得到，观察者通过主观质量对它们排序 结果被总结为在 NK平面上的 isopreference curves（等偏爱曲线）。坐落在同一条等偏爱曲线的点代表相同主观质量的图片。随着图片中的细节增多，等偏爱曲线趋近于更加垂直。这个结果表示对于有大量细节的图片只需要较少灰度等级。这个结果最有可能的原因是 k 的减小趋向于对比度的明显增加，一个人们通常感受到图像质量改善了的视觉效果。 2.4.4 Image Interpolation内插是使用在诸如放大、收缩、旋转和几何校正中的基础的工具。我们在这一节中的主要目标是介绍内插并将它应用调整图片大小中，这是基本的图片 resampling 方法。 根本上，interpolation 是使用已知数据去估算未知位置的数据的一个过程。假设一张 $500\times 500 pixels$ 的图像扩大 1.5 倍为 $750\times 750 pixels$。一个简单的放大方法是创建一个 $750\times 750$格的图像，再将其缩小到恰好覆盖原图像。显然 $750\times 750$ 的格子小于原图像的像素格。为了对覆盖的每个点赋以灰度等级，我们将原图上距离其最近的点的灰度赋给它，最后放大至原来大小。 上述方法被称为 nearest neighbor interpolation，因为它将新图上每个点的灰度安排为原图上最近的点。这个方法简单但可能产生不被期望的缺陷，比如直边缘的严重扭曲，因此它很少在实际中使用。一个更适合的方法是 bilinear interpolation ，其中我们用最近的四个邻近点去估算某个位置的灰度值。令 $(x,y)$ 代表新图上的坐标系，$v(x,y)$ 代表其灰度值。则 bilinear interpolation 可被写为：$v(x,y)=ax+by+cxy+d$。四个参数即点 $(x,y)$ 的四个最邻近点。伴随计算负担的适度增长，bilinear interpolation 给出了比 nearest neighbor interpolation 好得多的结果。 下一个复杂度的算法是 bicubic interpolation，它使用了一个点的十六最临近点：$v(x,y)=\sum_{i=0}^{3}\sum_{j=0}^{3}a_{ij}x^iy^j$。 2.5 Some Basic Relationships between Pixels在这一节里，我们考虑几个重要的数字图像的像素点间的关系。前面提到图像被表示为 $f(x,y)$，在这一节中当我们指一个特定的像素的时候，我们用小写字母表示，例如 p,q。 2.5.1 Neighbors of a Pixel一个像素点 p 有四个水平和竖直的邻居：$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$。这些点集被称为 p 的 4-neighbors，被称为 $N_4(p)$。四个对角邻居 $(x+1,y+1),(x+1,y-1),(x-1,y+1),(x-1,y-1)$被称为 $N_D(p)$。这些点被一起称为 p 的 8-neighbors，$N_8(p)$。当然有一些$N_4(p)$和$N_8(p)$的点可能落在边界外。 2.5.2 Adjacency, Connectivity, Regions, and Boundaries令 $V$ 为定义邻接性的灰度值集合。在二值图中当我们指值为 1 的像素点间的邻接性时 $V={1}$。在灰度图像中类似，但 $V$ 中包含更多值。我们考虑三种类型的邻接。 4-adjacency。当 $q \in N_4(p)$，具有 $V$ 中数值的两像素 p,q 是 4 邻接。 8-adjacency。当 $q \in N_8(p)$，具有 $V$ 中数值的两像素 p,q 是 8 邻接。 m-adjacency。当 $q \in N_4(p)$ 或 $q \in N_D(p)$ 且 $N_4(p)\cap N_4(q)$中的像素点的值都不属于$V$，具有 $V$ 中数值的两像素 p,q 是 m 邻接。 图 2.25 (a)(b)(c)显示了三者的不同。 一条从像素 p 到像素 q 的路径是一系列两两邻接的不同像素点：$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$。 令 $S$ 表示某张图像中像素点的集合。$S$ 中两像素点 p 和 q 被称为 connected，仅当存在一条完全由 $S$ 中像素点构成的路径。对任意 $S$ 中的 p，与它相连的 $S$ 的像素子集被称为 connected component。如果 $S$只有一个 connected component，则它被称为 connected set。 令 $R$ 为某张图片的像素子集。若 $R$ 为 connected set，我们称它为图片的 region。两 region 相连若它们的合集是 connected set。图2.25(c)(d)(e)是三中不同的邻接方式。 假设一张图片包含 K 个不邻接的 region，令 $R_u$ 代表所有 region 的集合，$(R_u)^c$ 代表其补集。我们称 $R_u$ 中的点为 foreground，$(R_u)^c$ 是图片的 background。]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>《Digital Image Processing [Gonzalez]》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dwango Programming Contest V (A,B,C)]]></title>
    <url>%2F2018%2F11%2F30%2FProgramming%20Contest%2FDwango-Programming-Contest-V%2F</url>
    <content type="text"><![CDATA[800分的题目都做不出.. 官方题解略长..告辞.. 地址 A - Thumbnail水签到。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[105];int main() &#123; scanf("%d", &amp;n); double s = 0; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), s += a[i]; s /= n; int ans = 0; for (int i = 1; i &lt; n; i++) if (fabs(a[ans]-s) &gt; fabs(a[i]-s)) ans = i; printf("%d\n", ans);&#125; B - Sum AND Subarrays题意找 k 个数字使其 and 之和最大 分析按位贪心，如果这位上 1 的个数大于 k，就把这位上是 0 的数字全部删掉，再处理下一位，小于 k 就跳过。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define pw(i) (1ull&lt;&lt;(i))typedef unsigned long long ull;const int N = 1005;int p[N], n, k;vector&lt;ull&gt; a, b;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;p[i]); for (int i = 1; i &lt;= n; i++) &#123; ull tmp = 0; for (int j = i; j &lt;= n; j++) &#123; tmp += p[j]; a.push_back(tmp); &#125; &#125; ull ans = 0; int t = 62; while (t &gt;= 0) &#123; int num = 0; for (auto x : a) if (x&amp;pw(t)) num++; if (num &gt;= k) &#123; ans ^= pw(t); for (auto x : a) if (x&amp;pw(t)) b.push_back(x); a = b; &#125; t--; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C - k-DMC题意给定长为 N 的字符串 S，Q 个询问，每个询问给一个 k，要你找三元组(a,b,c)的个数，要求 S[a]=&#39;D&#39;, S[b]=&#39;M&#39;, S[c] = &#39;C&#39; $c-a &lt; k$ 数据范围 $N \le 1e6, Q \le 75$ 分析看复杂度就知道$O(NQ)$挺合理。 枚举 &#39;C&#39;，这样每个询问变为$O(1)$求区间内 (&#39;D&#39;,&#39;M&#39;) 的对数。 预处理每个数字前面 &#39;D&#39; 的个数和每个数字前面 &#39;M&#39; 的个数，以及每个数字前 (&#39;D&#39;,&#39;M&#39;) 对数，这样就可以做到$O(1)$的区间查询了。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6+5;char s[N];int n, q;ll D[N], M[N], DM[N];int main() &#123; scanf("%d%s", &amp;n, s+1); for (int i = 1; i &lt;= n; i++) &#123; D[i] = D[i-1], M[i] = M[i-1]; DM[i] = DM[i-1]; if (s[i] == 'D') D[i]++; if (s[i] == 'M') M[i]++, DM[i] += D[i]; &#125; scanf("%d", &amp;q); while (q--) &#123; int k; scanf("%d", &amp;k); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (s[i] == 'C') &#123; int j = max(0, i-k); ans += DM[i]-DM[j]-D[j]*(M[i]-M[j]); &#125; &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 55(A-E,G)]]></title>
    <url>%2F2018%2F11%2F29%2FProgramming%20Contest%2FEducational-Codeforces-Round-55%2F</url>
    <content type="text"><![CDATA[一万个人会 G.. 已经记不得多久没写网络流了.. E 题 k=1的话还做做，大于1还没想好.. 这也太复杂了.. 这里的老哥敲题可真快.. 地址 A. Vasya and Book水分类讨论。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, x, y, d; scanf("%d%d%d%d", &amp;n, &amp;x, &amp;y, &amp;d); int ans = 1e9+5; if (x%d == y%d) ans = min(ans, abs(x-y)/d); if (1%d == y%d) ans = min(ans, (y-1)/d+(x-1)/d+1); if (n%d == y%d) ans = min(ans, (n-y)/d+(n-x)/d+1); if (ans == 1e9+5) ans = -1; printf("%d\n", ans); &#125;&#125; B. Vova and Trophies题意一个只包含 &#39;G&#39; &#39;S&#39; 的字符串，问你交换一次任意两个字符后，连续的 &#39;G&#39; 最多有多长 分析枚举 &#39;S&#39;，判断这个&#39;S&#39; 换成 &#39;G&#39; 后加上其两边的总长，稍作讨论。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int l[N], r[N];int n, num;char s[N];int main() &#123; scanf("%d%s", &amp;n, s+1); for (int i = 1; i &lt;= n; i++) if (s[i] == 'G') l[i] = l[i-1]+1, num++; for (int i = n; i &gt;= 1; i--) if (s[i] == 'G') r[i] = r[i+1]+1; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, l[i]); if (s[i] == 'S') &#123; if (num == l[i-1]+r[i+1]) ans = max(ans, l[i-1]+r[i+1]); else ans = max(ans, l[i-1]+r[i+1]+1); &#125; &#125; printf("%d\n", ans);&#125; C. Multi-Subject Competition题意给你每个学生的专攻方向和其技能等级，要求你所选的每个方向的人数都相同。 问你能得到的最大技能等级之和。 分析按专攻方向分类，再分别从大到小排序。 然后分别算出这个专业选 i 人对答案的共献，即max(0, sum of prefix[i])。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;vector&lt;int&gt; v[N];bool cmp1(int a, int b) &#123; return a &gt; b;&#125;ll res[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); v[a].push_back(b); &#125; for (int i = 1; i &lt;= m; i++) sort(v[i].begin(), v[i].end(), cmp1); for (int i = 1; i &lt;= m; i++) &#123; ll tmp = 0; for (int j = 0; j &lt; v[i].size(); j++) &#123; tmp += v[i][j]; if (tmp &lt; 0) break; res[j+1] += tmp; &#125; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, res[i]); cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Maximum Diameter Graph题意给你每个点的度数限制，问你不超过度数限制的情况下如何连边，使得连通图的直径最长。 分析点分为一度和大于一度。可以先判断下连不连通。 大于1度的点一定连成一条直线，然后头尾连俩一度的点，中间随便插即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 505;int n, d[N];vector&lt;int&gt; a, b;vector&lt;pii&gt; res;int main() &#123; int s = 0; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;d[i]); if (d[i] == 1) a.push_back(i); else b.push_back(i), s += d[i]-2; &#125; if ((int)a.size()-2 &gt; s) puts("NO"); else &#123; int ans = b.size() + min((int)a.size(),2); printf("YES %d\n", ans-1); if (b.size() == 0) &#123; puts("1 2"); return 0; &#125; for (int i = 0; i &lt; b.size()-1; i++) res.push_back(pii(b[i], b[i+1])); if (a.size() &gt;= 1) res.push_back(pii(b[0], a[0])); if (a.size() &gt;= 2) res.push_back(pii(b[b.size()-1], a[1])); int j = 0; for (int i = 2; i &lt; a.size(); i++) &#123; while (d[b[j]] &lt;= 2) j++; res.push_back(pii(a[i], b[j])); d[b[j]]--; &#125; printf("%d\n", res.size()); for (auto p : res) printf("%d %d\n", p.first, p.second); &#125;&#125; E. Increasing Frequency题意给定一个数字序列。你有一次区间加法的机会，问操作后连续的数字 c 最多是多少个。 分析不同数字分别考虑。然后 DP，对每个位置而言分别有三个状态：操作区间前，操作区间中，操作区间后。从前一个位置转移即可。 (代码写得略烂..写得我自己都有点浑..) 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+5;int n, c, a[N];int num[N];vector&lt;int&gt; v[N];int dp[N][3];int main() &#123; scanf("%d%d", &amp;n, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); num[i] = num[i-1]; if (a[i] == c) num[i]++; v[a[i]].push_back(i); &#125; int ans = num[n]; for (int i = 1; i &lt; N; i++) &#123; if (i == c) continue; if (!v[i].size()) continue; dp[0][0] = num[v[i][0]]; dp[0][1] = num[v[i][0]]+1; dp[0][2] = 0; for (int j = 1; j &lt; v[i].size(); j++) &#123; int tmp = num[v[i][j]]-num[v[i][j-1]]; dp[j][0] = dp[j-1][0] + tmp; dp[j][1] = max(dp[j-1][0] + tmp+1, dp[j-1][1]+1); dp[j][2] = max(dp[j-1][2], dp[j-1][1]) + tmp; &#125; int m = v[i].size(); ans = max(ans, dp[m-1][2]+num[n]-num[v[i][m-1]]); ans = max(ans, dp[m-1][0]+num[n]-num[v[i][m-1]]); ans = max(ans, dp[m-1][1]+num[n]-num[v[i][m-1]]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; G. Petya and Graph题意选了边就要选两头的点。问你最终选出的子图边权减点权最大是多少。 分析最大权闭合子图.. 由于是二分图，复杂度不超过 O(n*m) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Edge &#123; Edge() &#123;&#125; Edge(int a, int b, ll c, ll d) :from(a), to(b), cap(c), flow(d) &#123;&#125; int from, to; ll cap, flow;&#125;;const int N = 2e3+5;const ll INF = 1e18;struct Dinic &#123; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[N]; bool vis[N]; int d[N], cur[N], s, t; void Init() &#123; for (int i = 0; i &lt; N; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, ll cap) &#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int x = edges.size(); G[from].push_back(x - 2); G[to].push_back(x - 1); &#125; bool BFS() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = 0; i&lt;G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; ll DFS(int x, ll a) &#123; if (x == t || a == 0) return a; ll flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; &#125; &#125; return flow; &#125; ll MaxFlow(int s, int t) &#123; this-&gt;s = s; this-&gt;t = t; ll flow = 0; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;dinic;int n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int st = N-1, ed = N-2; for (int i = 1; i &lt;= n; i++) &#123; int w; scanf("%d", &amp;w); dinic.AddEdge(i, ed, w); &#125; ll ans = 0; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); dinic.AddEdge(st, n+i, w); dinic.AddEdge(n+i, u, INF); dinic.AddEdge(n+i, v, INF); ans += w; &#125; ans -= dinic.MaxFlow(st, ed); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #522 (Div. 2) (A-E)]]></title>
    <url>%2F2018%2F11%2F20%2FProgramming%20Contest%2FCodeforces-Round-522-Div-2%2F</url>
    <content type="text"><![CDATA[分类讨论场么.. 地址 A. Kitchen Utensils水签到。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n, k, a[105];int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[x]++; &#125; int num = 0; for (int i = 1; i &lt;= 100; i++) num = max(num, ((a[i]-1)/k+1)*k); int ans = 0; for (int i = 1; i &lt;= 100; i++) if (a[i]) ans += num-a[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Personalized Cup先算出行数列数，再竖着填’*&#39;，横着填字符呗。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char s[N], ans[N][N];int main() &#123; scanf("%s", s); int n = strlen(s); int r = (n-1)/20+1; int c = (n-1)/r+1; int m = r*c; for (int i = 0; i &lt; c; i++) &#123; if (m == n) break; for (int j = 0; i &lt; r; j++) &#123; if (m == n) break; ans[j][i] = '*'; m--; &#125; &#125; int x = 0; for (int i = 0; i &lt; r; i++) for (int j = 0; j &lt; c; j++) &#123; if (ans[i][j] == '*') continue; ans[i][j] = s[x++]; &#125; for (int i = 0; i &lt; r; i++) ans[i][c] = '\0'; printf("%d %d\n", r, c); for (int i = 0; i &lt; r; i++) printf("%s\n", ans[i]);&#125; C. Playing Pianodp[i][j] 表示 第 i 位填 j 是否可行，一遍 dp 顺便记录前驱即可。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;int n, a[N];int dp[N][6];int cal(int x, int l, int r) &#123; for (int i = l; i &lt;= r; i++) if (dp[x][i]) return i; return 0;&#125;int b[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= 5; i++) dp[1][i] = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= 5; j++) &#123; if (a[i] &lt; a[i-1]) dp[i][j] = cal(i-1, j+1, 5); else if (a[i] &gt; a[i-1]) dp[i][j] = cal(i-1, 1, j-1); else dp[i][j] = max(cal(i-1, 1, j-1), cal(i-1, j+1, 5)); &#125; &#125; for (int i = 1; i &lt;= 5; i++) if (dp[n][i]) &#123; b[n] = i; break; &#125; if (!b[n]) puts("-1"); else &#123; for (int i = n-1; i &gt;= 1; i--) &#123; b[i] = dp[i+1][b[i+1]]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%d", b[i]); if (i == n) puts(""); else printf(" "); &#125; &#125;&#125; D. Barcelonian Distance借用直线和不借用直线都算一遍，借用直线就是延 x 轴或者 y 轴先走到直线。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;double a, b, c, x1, y1, x2, y2;double ans;double solve(double x3, double y3, double x4, double y4) &#123; return fabs(x3-x1)+fabs(y3-y1)+hypot(fabs(x3-x4), fabs(y3-y4))+fabs(x4-x2)+fabs(y4-y2);&#125;int main() &#123; scanf("%lf%lf%lf%lf%lf%lf%lf", &amp;a, &amp;b, &amp;c, &amp;x1, &amp;y1, &amp;x2, &amp;y2); ans = fabs(x1-x2)+fabs(y1-y2); if (b) ans = min(ans, solve(x1, -(a*x1+c)/b, x2, -(a*x2+c)/b)); if (a) ans = min(ans, solve(-(b*y1+c)/a, y1, -(b*y2+c)/a, y2)); if (a&amp;&amp;b) &#123; ans = min(ans, solve(x1, -(a*x1+c)/b, -(b*y2+c)/a, y2)); ans = min(ans, solve(-(b*y1+c)/a, y1, x2, -(a*x2+c)/b)); &#125; printf("%.10f\n", ans);&#125; E. The Unbearable Lightness of Weights题意给你 n 个物体的重量和 n 个物体，你只能问你朋友一次 (a,b)，朋友会选 b 个物体总重为 a。 问你最多能确定几个物体的重量。 分析如果只有两个重量，就都可以确定。 有三个以上的重量，只能确定一种重量，即全部选同一种重量的物体且其总重的组成方案唯一。 dp[i][j] 表示总重为 i 的 j 个物体的方案数，多重背包即可。 复杂度 1e8 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[105];bool check() &#123; int cnt = 0; for (int i = 1; i &lt;= 100; i++) if (a[i]) cnt++; return cnt &lt;= 2;&#125;int dp[2][10001][101];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); a[x]++; &#125; if (check()) &#123; int ans = 0; for (int i = 1; i &lt;= 100; i++) ans += a[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; dp[0][0][0] = 1; for (int i = 1; i &lt;= 100; i++) &#123; memcpy(dp[1], dp[0], sizeof(dp[0])); for (int j = 1; j &lt;= a[i]; j++) &#123; for (int k = i*j; k &lt;= 10000; k++) for (int l = j; l &lt;= 100; l++) dp[1][k][l] = min(2, dp[1][k][l]+dp[0][k-i*j][l-j]); &#125; memcpy(dp[0], dp[1], sizeof(dp[0])); &#125; int ans = 0; for (int i = 1; i &lt;= 100; i++) for (int j = 1; j &lt;= a[i]; j++) if (dp[0][i*j][j] == 1) &#123; ans = max(ans, j); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #520 (Div. 2)（A-E）]]></title>
    <url>%2F2018%2F11%2F18%2FProgramming%20Contest%2FCodeforces-Round-520-Div-2%2F</url>
    <content type="text"><![CDATA[感觉数学题略多. F 题解太长了..告辞.. 地址 A. Minimizing the String水签到。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); a[0] = 0, a[n+1] = 1001; int cnt = 1, ans = 0; for (int i = 1; i &lt;= n+1; i++) &#123; if (a[i] == a[i-1]+1) cnt++; else ans = max(ans, cnt-2), cnt = 1; &#125; ans = max(ans, cnt-2); cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Math题意给你一个数字 n，两个操作：乘上任意一个数；开根号（要求是平方数） 问最小能得到的数字是多少，至少几次操作 分析先上唯一分解定理，最小能得到的数字一定是 n 的所有质因子乘积。 最小次数可按每个质因子分开讨论，因为开根号即为质因子个数除以 2，故先把质因子个数加成二的幂再不断除。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;bool notp[N];int prime[N], pnum;void sieve() &#123; memset(notp, 0, sizeof(notp)); notp[0] = notp[1] = 1; pnum = 0; for (int i = 2; i &lt; N; i++) &#123; if (notp[i] == 0) prime[++pnum] = i; for (int j = 1; j &lt;= pnum &amp;&amp; prime[j] * i &lt; N; j++) &#123; notp[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int n;int main() &#123; sieve(); scanf("%d", &amp;n); int m = n; bool f = 0; int ans1 = 1, ans2 = 0, tmp = 0; for (int i = 1; i &lt;= pnum; i++) &#123; if (m % prime[i] == 0) &#123; int cnt = 0; while (m%prime[i] == 0) cnt++, m /= prime[i]; ans1 *= prime[i]; if (tmp &amp;&amp; cnt != tmp) f = 1; tmp = max(tmp, cnt); &#125; &#125; if (ans1 == n) &#123; printf("%d 0\n", ans1); &#125; else &#123; int x = 1; while (x &lt; tmp) x *= 2, ans2++; if (f || x != tmp) ans2++; printf("%d %d\n", ans1, ans2); &#125;&#125; C. Banh-mi题意先给你一个01串，有 q 个区间询问 操作是先在区间内选一个位置，然后把它吃掉，得到那个位置的得分，并且区间内剩余位置的得分全部加上那个位置的得分 每次询问问该区间所能得到的最大的分是多少 分析先吃大的再吃小的最优，由于只有 0 和 1 ，就先吃 1 再吃 0 每个位置对答案的贡献可单独计算，即 1011 可看作 1000：1+1+2+4 = 2^3 100：1+1+2 = 2^2 10：1+1 = 2^1 这是第一组样例，所以很明白了。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;const int MOD = 1e9+7;ll pw2[N];int n, q, sum[N];char s[N];int main() &#123; scanf("%d%d%s", &amp;n, &amp;q, s+1); pw2[0] = 1; for (int i = 1; i &lt;= n; i++) pw2[i] = pw2[i-1]*2%MOD; for (int i = 1; i &lt;= n; i++) pw2[i] = (pw2[i] + pw2[i-1]) % MOD; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i-1] + s[i]-'0'; while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = r-l+1, b = sum[r]-sum[l-1]; ll ans = pw2[a-1]; if (a &gt; b) ans = (ans + MOD - pw2[a-b-1]) % MOD; printf("%lld\n", ans); &#125;&#125; D. Fun with Integers题意绝对值小于 n 的数字（除了0，1，-1），让每个数字与其倍数（除去 -1）连边，边权是两者之商的绝对值，问每条边限走一遍能得到的最大权值和是多少 分析由于每个点度数都是偶数，故存在欧拉回路。所以每个连通分量里的每条边都能访问到。 实际上根据题解的证明（图中每条边都在同一个连通分量内）可以写出 这样 复杂度$O(\sqrt{n})$的代码。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int f[N];ll sum[N];int sf(int x) &#123; return x == f[x] ? x : f[x] = sf(f[x]);&#125;int n;int main() &#123; for (int i = 0; i &lt; N; i++) f[i] = i; scanf("%d", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; for (int j = i+i; j &lt;= n; j += i) &#123; f[sf(i)] = sf(j); sum[i] += 4*(j/i); &#125; &#125; for (int i = 1; i &lt;= n; i++) if (sf(i) != i) sum[sf(i)] += sum[i]; ll ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, sum[sf(i)]); printf("%lld\n", ans);&#125; E. Company题意给定一棵有根树，q 个区间询问。 对于每个询问，要求区间内删去一个点后剩余点的 LCA 的深度，问删哪个点，深度最大多少 分析没记错的话去年多校训练碰到过类似题目。 先对每个点求 DFS 序，由于所有点的 LCA 的 DFS 序的作用域一定是恰好包含所有点的 DFS 序，即这些点的 LCA 即为 DFS 序最小的和最大的两个点的 LCA 。 故删掉的一定是 DFS 序最小的点或者最大的点。 倍增求 LCA + ST 表，复杂度$O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define pw(i) (1&lt;&lt;(i))const int N = 1e5+5;const int LEV = 20;vector&lt;int&gt; G[N];int dph[N], fa[N][LEV];int L[N], dfs_clock, F[N]; // dfs序和逆映射void dfs(int rt, int f) &#123; L[rt] = ++dfs_clock; F[dfs_clock] = rt; for (int i = 1; i &lt; LEV; i++) &#123; if (dph[rt]-1 &lt; pw(i)) break; fa[rt][i] = fa[fa[rt][i-1]][i-1]; &#125; for (int v : G[rt]) &#123; dph[v] = dph[rt]+1; fa[v][0] = rt; dfs(v, rt); &#125;&#125;int lca(int a, int b) &#123; if (dph[a] &lt; dph[b]) swap(a, b); int t = dph[a]-dph[b]; for (int i = 0; i &lt; LEV; i++) if (pw(i)&amp;t) a = fa[a][i]; for (int i = LEV-1; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; if (a != b) return fa[a][0]; return a;&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); memset(fa, 0, sizeof(fa)); dph[1] = 1; dfs_clock = 0;&#125;int Min[N][20], Max[N][20], lg2[N];void Init(int a[], int n) &#123; for (int i = 2; i &lt;= n; i++) lg2[i] = lg2[i/2]+1; for (int i = 1; i &lt;= n; i++) Min[i][0] = Max[i][0] = a[i]; for (int j = 1; j &lt;= lg2[n]; j++) for (int i = 1; i+pw(j)-1 &lt;= n; i++) &#123; Min[i][j] = min(Min[i][j-1], Min[i+pw(j-1)][j-1]); Max[i][j] = max(Max[i][j-1], Max[i+pw(j-1)][j-1]); &#125;9&#125;int Qmin(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return min(Min[l][k], Min[r+1-pw(k)][k]);&#125;int Qmax(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return max(Max[l][k], Max[r+1-pw(k)][k]);&#125;int solve(int l, int a, int r) &#123; if (a == l) return lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); if (a == r) return lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f1 = lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f2 = lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); return lca(f1, f2);&#125;int main() &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); init(n);//multiLCA-init for (int i = 2; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); G[x].push_back(i); &#125; dfs(1, 1); Init(L, n);//ST-init while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = F[Qmin(l, r)], b = F[Qmax(l, r)]; int fa = solve(l, a, r), fb = solve(l, b, r); if (dph[fa] &gt; dph[fb]) printf("%d %d\n", a, dph[fa]-1); else printf("%d %d\n", b, dph[fb]-1); &#125;&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 54 (A-F)]]></title>
    <url>%2F2018%2F11%2F16%2FProgramming%20Contest%2FEducational-Codeforces-Round-54%2F</url>
    <content type="text"><![CDATA[日常掉分.. D 被无良学弟 hack 了，这个故事告诉我们 CF 上不要写spfa... E 比赛时候觉得挺难的（然后溜了），赛后仔细分析了下觉得还是挺妙的。 F 傻傻分析不清，然而题解分析的贼清楚.. 最后一题日常不会.. 地址 A. Minimizing the String题意删除一个字符使得字典序最小 分析贪心呀，从前往后删第一个 s[i]&gt;s[i-1]。或者最后一个。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;char s[N];int n;int main() &#123; cin &gt;&gt; n &gt;&gt; s; int ans = n-1; for (int i = 0; i &lt; n-1; i++) &#123; if (s[i] &gt; s[i+1]) &#123; ans = i; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == ans) continue; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl;&#125; B. Divisor Subtraction题意给一个数字 n，每次减去其最小质因子，重复此步骤，问共几次减到 0 分析如果 n 是质数，就一次。 如果 n 是偶数，就 n/2。 如果 n 是奇数，最小质因子 d 一定是奇数，故 (n-d)/2+1 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;ll n;ll solve(ll n) &#123; if (n%2 == 0) return n/2; for (ll i = 2; i*i &lt;= n; i++) if (n%i == 0) return 1+(n-i)/2; return 1;&#125;int main() &#123; cin &gt;&gt; n; cout &lt;&lt; solve(n) &lt;&lt; endl;&#125; C. Meme Problem解一元二次方程 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;int t, d;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;d); if (d*d-4*d &lt; 0) puts("N"); else &#123; double a = (d+sqrt(d*d-4*d))/2; double b = (d-sqrt(d*d-4*d))/2; printf("Y %.9f %.9f\n", a, b); &#125; &#125;&#125; D. Edge Deletion题意给你一张图，有边权。问你最多留下哪 k 条边，使得原图和新图中由 1 的最短路长度不变的点留下的最多 分析先建由 1 出发的最短路树，把多余的边全删掉。 还不够的话，从叶子开始删边。（拓扑排序或者别的什么） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const ll INF = 1e18;struct Edge &#123; int v; ll w; int id; bool operator &lt; (const Edge&amp; b) const &#123; return w &gt; b.w; &#125;&#125;;vector&lt;Edge&gt; G[N];void addedge(int u, int v, int w, int id) &#123; G[u].push_back(Edge&#123;v, w, id&#125;);&#125;int pre[N], f[N];ll d[N];bool vis[N];typedef Edge Node;priority_queue&lt;Node&gt; Q;void Dijkstra(int s, int n) &#123; while (!Q.empty()) Q.pop(); for (int i = 0; i &lt;= n; i++) d[i] = INF, vis[i] = 0; d[s] = 0; Q.push(Node&#123;s, 0&#125;); while (!Q.empty()) &#123; Node tmp = Q.top(); Q.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = 1; for (const auto&amp; e : G[u]) &#123; if (!vis[e.v] &amp;&amp; d[e.v] &gt; d[u] + e.w) &#123; d[e.v] = d[u] + e.w; pre[e.v] = e.id; f[e.v] = u; Q.push(Node&#123;e.v, d[e.v]&#125;); &#125; &#125; &#125;&#125;int n, m, k;int cnt[N];bool val[N];queue&lt;int&gt; que;void solve() &#123; for (int i = 2; i &lt;= n; i++) cnt[f[i]]++; for (int i = 1; i &lt;= n; i++) &#123; if (!cnt[i]) que.push(i); &#125; while (!que.empty()) &#123; int v = que.front(); que.pop(); val[pre[v]] = 0; k++; if (k == 0) return; cnt[f[v]]--; if (!cnt[f[v]]) que.push(f[v]); &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; Dijkstra(1, n); for (int i = 2; i &lt;= n; i++) val[pre[i]] = 1; for (int i = 1; i &lt;= m; i++) &#123; if (val[i]) k--; &#125; if (k &lt; 0) solve(); for (int i = 1; i &lt;= m; i++) if (val[i]) ans.push_back(i); printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; E. Vasya and a Tree题意给定一棵树和若干操作。操作 (v,d,x) 是 v 的子树中与 v 距离小于等于 d 的节点权值都加上 x 问所有操作结束后的每个点的权值。 分析操作可离线。建一棵基于深度的线段树（或者树状数组），在 DFS 不断修改和查询。 单次修改相当于 区间 [dps(v), dps(v)+d] 加上 x 。 区间修改单点查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int N = 3e5+5;vector&lt;int&gt; G[N];vector&lt;pii&gt; Q[N];ll c[N];void modify(int x, int num) &#123; while (x &lt; N) c[x] += num, x += x&amp;-x;&#125;ll sum(int x) &#123; ll s = 0; while (x) s += c[x], x -= x&amp;-x; return s;&#125;ll ans[N];int dps[N];void DFS(int u, int pre) &#123; dps[u] = dps[pre]+1; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u], x); modify(dps[u]+d+1, -x); &#125; ans[u] = sum(dps[u]); for (auto v : G[u]) &#123; if (v == pre) continue; DFS(v, u); &#125; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u],-x); modify(dps[u]+d+1, x); &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); G[a].push_back(b); G[b].push_back(a); &#125; int q; scanf("%d", &amp;q); while (q--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); Q[a].push_back(pii(b, c)); &#125; DFS(1, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Summer Practice Report题意魔改题意。有 n 个连续的区间，告诉你每个区间里需要放\(x_i\)个物体 a，(y_i\)个物体 b 问你是否有一种放置方法，能不出现连续 k 个以上的 a 或 b（可跨区间）。 分析设 \(dp[i][0]\) 表示第 i 个区间， 若以 a 物体结尾，末尾最少的 a 物体数量。\(dp[i][1]\)类似。 最后判断 \(dp[n][0]\) 或 \(dp[n][1]\) 是否满足要求即可。 考虑 \(dp[i-1][0]\)转移至\(dp[i][0]\)： ​ 首先要满足 \(x_i \ge \lceil\frac{y_i}{k}\rceil\)，即每 k 个 b 物体后插入一个 a 。 ​ 然后当 \(x_i \le y_i*k+1 - dp[i-1][0] \) 时，某尾 a 的数量始终为 1，即每个 b 前面插满 k 个 a ，包括上一段的。 ​ \(x_i\)还多的话，则最少为 \(x_i-(y_i*k-dp[i-1][0])\)。 可同理考虑\(dp[i-1][1]\)转移至\(dp[i][0]\)，以及\(dp[i][1]\)的转移。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5+5;int n, k;int x[N], y[N];int dp[N][2];int solve1(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y+pre-1)/k+1) return k+1; if (x &lt;= 1ll*y*k) return 1; return x-1ll*y*k;&#125;int solve2(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y-1)/k+1) return k+1; if (x &lt;= 1ll*y*k-pre) return 1; return x-(1ll*y*k-pre);&#125;bool solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = min(solve1(dp[i-1][1], x[i], y[i]), solve2(dp[i-1][0], x[i], y[i])); dp[i][1] = min(solve1(dp[i-1][0], y[i], x[i]), solve2(dp[i-1][1], y[i], x[i])); &#125; return dp[n][0] &lt;= k || dp[n][1] &lt;= k;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;y[i]); if (solve()) puts("YES"); else puts("NO");&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #519 (A-F)]]></title>
    <url>%2F2018%2F11%2F13%2FProgramming%20Contest%2FCodeforces-Round-519-A-F%2F</url>
    <content type="text"><![CDATA[水一把 CF，感觉全暴力而且代码量略少。 G 题不会..打扰了.. 地址 A. Elections公式解即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); int s = 0, k = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; k = max(k, a[i]); &#125; k = max(k, s*2/n+1); printf("%d\n", k);&#125; B. Lost ArrayKMP 的 next 函数求出所有循环节。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int n, a[N], nxt[N];void GetNxt(int s[], int n) &#123; int j = 0, k = -1; nxt[0] = -1; while(j &lt; n) &#123; if (k != -1 &amp;&amp; s[j] != s[k]) k = nxt[k]; else nxt[++j] = ++k; &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = n; i &gt;= 1; i--) a[i] -= a[i-1]; GetNxt(a+1, n); int m = n; while (nxt[m] &gt;= 0) &#123; ans.push_back(n-nxt[m]); m = nxt[m]; &#125; printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; C. Smallest Word题意给定一个只有字符 a,b 的串，问按顺序 reverse 哪几个前缀可以使其字典序最小。 分析转几次就会发现所有的 a 和所有的 b 是可以转到一起的，故先转到一起，最后转到 a 在前 b 在后即可。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;char s[N];bool val[N];int main() &#123; scanf("%s", &amp;s); int n = strlen(s); char now = s[0]; for (int i = 0; i &lt; n; i++) &#123; if (s[i] != now) &#123; val[i-1] = 1; now = s[i]; &#125; &#125; if (now == 'a') val[n-1] = 1; for (int i = 0; i &lt; n; i++) &#123; printf("%d", val[i]); if (i == n-1) puts(""); else printf(" "); &#125;&#125; D. Mysterious Crime题意给定10个排列，问它们的相同子串的个数。 分析由于是排列，故每个数字唯一双射一个位置。 可直接按第一个串的子串找，相当于把第一个串分成好多段，每一段都是一个相同子串，由此计数。 具体分法，即某一段是否在某个位置结束，只用看第一段这个位置和其他串的对应位置是否映射同一个数字。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;int a[11][N], pos[11][N];bool vis[N];bool check(int x, int cnt) &#123; for (int i = 1; i &lt;= m; i++) if (pos[i][x]+cnt &gt; n) return 0; for (int i = 2; i &lt;= m; i++) if (a[i][pos[i][x]+cnt] != a[i-1][pos[i-1][x]+cnt]) return 0; return 1;&#125;int main() &#123; scanf("%d%d",&amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); pos[i][a[i][j]] = j; &#125; if (m == 1) &#123; printf("%lld\n",1ll*n*(n+1)/2); return 0; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; while(check(a[1][i], cnt)) cnt++; ans += 1ll*cnt*(cnt+1)/2; i += cnt-1; &#125; printf("%lld\n", ans);&#125; D - Crossing题意给定 n 个 (x,y) ，两两匹配的贡献是\(min(a_x+b_y,a_y+b_x)\) 然后除掉给定的m对匹配后，问你剩余的两两匹配之和。 分析按 \(a_x+b_y&lt;a_y+b_x\) 即 \(a_x-a_y&lt;b_x-b_y\) 排序后直接算即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;int n, m;struct Node &#123; int x, y, id; bool operator &lt; (const Node b) const &#123; return x-y &lt; b.x-b.y; &#125;&#125;a[N];ll x[N], y[N];ll ans[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); int res = min(a[u].x+a[v].y, a[u].y+a[v].x); ans[u] -= res; ans[v] -= res; &#125; sort(a+1, a+1+n); for (int i = 1; i &lt;= n; i++) x[i] = x[i-1] + a[i].x; for (int i = n; i &gt;= 1; i--) y[i] = y[i+1] + a[i].y; for (int i = 1; i &lt;= n; i++) &#123; ans[a[i].id] += 1ll*a[i].y*(i-1)+x[i-1]; ans[a[i].id] += 1ll*a[i].x*(n-i)+y[i+1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Make It One题意从 n(3e5) 个给定的数字中选一组 gcd 为 1 的数，最少选几个 分析根据唯一分解定理，每选择一个数字至少消去一种素因子，而前 7 个素因子之积已超过 3e5，故至多选7个。 \(dp[i][j]\) 表示 i 的倍数中选出 j 个，且 gcd 为 i 的方案数 ： $$dp[i][j] = \binom{cnt_i}{j}-\sum_{k=2}^{\infty}dp[i*k][j]$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const int MOD = 1e9+7;int F[N], Finv[N], inv[N];void init() &#123; inv[1] = 1; for (int i = 2; i &lt; N; i ++) &#123; inv[i] = (MOD - MOD / i) * 1ll * inv[MOD % i] % MOD; &#125; F[0] = Finv[0] = 1; for (int i = 1; i &lt; N; i ++) &#123; F[i] = F[i-1] * 1ll * i % MOD; Finv[i] = Finv[i-1] * 1ll * inv[i] % MOD; &#125;&#125;int comb(int n, int m) &#123; if (m &lt; 0 || m &gt; n) return 0; return F[n] * 1ll * Finv[n - m] % MOD * Finv[m] % MOD;&#125;int n, cnt[N];ll dp[N][10];int main() &#123; init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt[x]++; &#125; for (int i = 1; i &lt; N; i++) for (int j = i+i; j &lt; N; j += i) cnt[i] += cnt[j]; for (int i = N-1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= 7; j++) &#123; dp[i][j] = comb(cnt[i], j); for (int k = i+i; k &lt; N; k += i) dp[i][j] = (dp[i][j] + MOD - dp[k][j]) % MOD; &#125; &#125; int ans = -1; for (int i = 7; i &gt;= 1; i--) if (dp[1][i]) ans = i; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest (C,D,E)]]></title>
    <url>%2F2018%2F10%2F28%2FProgramming%20Contest%2FTenka1-Programmer-Contest%2F</url>
    <content type="text"><![CDATA[第一把 AtCoder，可以说是真的菜了，E 题调到死都没调出来... 地址 C - Align题意给定 n 个数字，要求排成一排后任意两个数字之差的绝对值之和最大，求最大值 分析一定是将数列排序后分成两半，前一半和后一半交替排列。绝对值符号可以去掉，然后每个数字计算次数只跟其位置有关，最后分类讨论一下就好了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+1+n); if (n%2 == 0) &#123; ll ans = 0; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; ans -= a[n/2]; ans += a[n/2+1]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; ll ans = 0; ans -= a[n/2]; ans -= a[n/2+1]; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; ll ans2 = 0; for (int i = 1; i &lt;= n/2; i++) ans2 -= 2*a[i]; ans2 += a[n/2+2]; ans2 += a[n/2+1]; for (int i = n/2+3; i &lt;= n; i++) ans2 += 2*a[i]; ans = max(ans, ans2); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D - Crossing题意给定 n，问是否存在这样的集合组： 1-n 每个数字都恰好被包含在两个集合中 任意两个集合仅有一个相同数字 分析n 条边的完全图 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n;int check(int n) &#123; for (int i = 1; i*(i-1)/2 &lt;= n; i++) if (i*(i-1)/2 == n) return i; return 0;&#125;int mp[505][505];int main() &#123; scanf("%d", &amp;n); int k = check(n); if (!k) puts("No"); else &#123; puts("Yes"); for (int i = 1; i &lt;= k; i++) for (int j = i+1; j &lt;= k; j++) mp[i][j] = mp[j][i] = n--; printf("%d\n", k); for (int i = 1; i &lt;= k; i++) &#123; printf("%d", k-1); for (int j = 1; j &lt;= k; j++) &#123; if (j == i) continue; printf(" %d", mp[i][j]); &#125; puts(""); &#125; &#125;&#125; E - Equilateral题意给出一张仅含 &#39;#&#39; 和 &#39;*&#39; 的矩阵，问位置三元组的数目，其满足每个位置上的字符都是 &#39;#&#39; 且任意两点的麦哈顿距离相同 分析跟题解大致相同的思路。 中心红点是三点麦哈顿距离的交点。a 和 b 长度相同，第三个点坐落在蓝线上。故先枚举中间的红点，再枚举另外俩红点的位置，统计蓝线上的点的数目即可。预处理斜线前缀和，复杂度O(n^3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 305;int n, m;char mp[3*N][3*N];int suml[3*N][3*N], sumr[3*N][3*N];ll solve(int x, int y) &#123; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; if (mp[x-i][y] == '#') num++; if (mp[x+i][y] == '#') num++; if (mp[x][y-i] == '#') num++; if (mp[x][y+i] == '#') num++; if (num == 3) ans++; else if (num == 4) ans += 4; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x+1, sy = y+i-1; int ex = x+i-1, ey = y+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x+1, sy = y-i+1; int ex = x+i-1, ey = y-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x-i+1, sy = y-1; int ex = x-1, ey = y-i+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x-i+1, sy = y+1; int ex = x-1, ey = y+i-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = N+1; i &lt;= N+n; i++) scanf("%s", mp[i]+1+N); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) suml[i][j] = sumr[i][j] = (mp[i][j] == '#'); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) &#123; sumr[i][j] += sumr[i-1][j-1]; suml[i][j] += suml[i-1][j+1]; &#125; ll ans = 0; for (int i = N+1; i &lt;= N+n; i++) for (int j = N+1; j &lt;= N+m; j++) ans += solve(i, j); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>Programming Contest</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
