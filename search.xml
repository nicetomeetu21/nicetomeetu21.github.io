<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest (C,D,E)]]></title>
    <url>%2F2018%2F10%2F28%2FTenka1-Programmer-Contest%2F</url>
    <content type="text"><![CDATA[第一把 AtCoder，可以说是真的菜了，E 题调到死都没调出来… 地址 C - Align题意给定 n 个数字，要求排成一排后任意两个数字之差的绝对值之和最大，求最大值 分析一定是将数列排序后分成两半，前一半和后一半交替排列。绝对值符号可以去掉，然后每个数字计算次数只跟其位置有关，最后分类讨论一下就好了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+1+n); if (n%2 == 0) &#123; ll ans = 0; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; ans -= a[n/2]; ans += a[n/2+1]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; ll ans = 0; ans -= a[n/2]; ans -= a[n/2+1]; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; ll ans2 = 0; for (int i = 1; i &lt;= n/2; i++) ans2 -= 2*a[i]; ans2 += a[n/2+2]; ans2 += a[n/2+1]; for (int i = n/2+3; i &lt;= n; i++) ans2 += 2*a[i]; ans = max(ans, ans2); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D - Crossing题意给定 n，问是否存在这样的集合组： 1-n 每个数字都恰好被包含在两个集合中 任意两个集合仅有一个相同数字 分析n 条边的完全图 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n;int check(int n) &#123; for (int i = 1; i*(i-1)/2 &lt;= n; i++) if (i*(i-1)/2 == n) return i; return 0;&#125;int mp[505][505];int main() &#123; scanf("%d", &amp;n); int k = check(n); if (!k) puts("No"); else &#123; puts("Yes"); for (int i = 1; i &lt;= k; i++) for (int j = i+1; j &lt;= k; j++) mp[i][j] = mp[j][i] = n--; printf("%d\n", k); for (int i = 1; i &lt;= k; i++) &#123; printf("%d", k-1); for (int j = 1; j &lt;= k; j++) &#123; if (j == i) continue; printf(" %d", mp[i][j]); &#125; puts(""); &#125; &#125;&#125; E - Equilateral题意给出一张仅含 ‘#’ 和 ‘*’ 的矩阵，问位置三元组的数目，其满足每个位置上的字符都是 ‘#’ 且任意两点的麦哈顿距离相同 分析跟题解大致相同的思路。 a 和 b 长度相同，第三个点坐落在蓝线上。故先枚举中间的红点，再枚举另外俩红点的位置，统计蓝线上的点的数目即可。预处理斜线前缀和，复杂度O(n^3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 305;int n, m;char mp[3*N][3*N];int suml[3*N][3*N], sumr[3*N][3*N];ll solve(int x, int y) &#123; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; if (mp[x-i][y] == '#') num++; if (mp[x+i][y] == '#') num++; if (mp[x][y-i] == '#') num++; if (mp[x][y+i] == '#') num++; if (num == 3) ans++; else if (num == 4) ans += 4; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x+1, sy = y+i-1; int ex = x+i-1, ey = y+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x+1, sy = y-i+1; int ex = x+i-1, ey = y-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x-i+1, sy = y-1; int ex = x-1, ey = y-i+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x-i+1, sy = y+1; int ex = x-1, ey = y+i-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = N+1; i &lt;= N+n; i++) scanf("%s", mp[i]+1+N); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) suml[i][j] = sumr[i][j] = (mp[i][j] == '#'); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) &#123; sumr[i][j] += sumr[i-1][j-1]; suml[i][j] += suml[i-1][j+1]; &#125; ll ans = 0; for (int i = N+1; i &lt;= N+n; i++) for (int j = N+1; j &lt;= N+m; j++) ans += solve(i, j); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
