<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #519 (A-F)]]></title>
    <url>%2F2018%2F11%2F13%2FCodeforces-Round-519-A-F%2F</url>
    <content type="text"><![CDATA[水一把 CF，感觉全暴力而且代码量略少。 G 题不会..打扰了.. 地址 A. Elections公式解即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); int s = 0, k = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; k = max(k, a[i]); &#125; k = max(k, s*2/n+1); printf("%d\n", k);&#125; B. Lost ArrayKMP 的 next 函数求出所有循环节。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int n, a[N], nxt[N];void GetNxt(int s[], int n) &#123; int j = 0, k = -1; nxt[0] = -1; while(j &lt; n) &#123; if (k != -1 &amp;&amp; s[j] != s[k]) k = nxt[k]; else nxt[++j] = ++k; &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = n; i &gt;= 1; i--) a[i] -= a[i-1]; GetNxt(a+1, n); int m = n; while (nxt[m] &gt;= 0) &#123; ans.push_back(n-nxt[m]); m = nxt[m]; &#125; printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; C. Smallest Word题意给定一个只有字符 a,b 的串，问按顺序 reverse 哪几个前缀可以使其字典序最小。 分析转几次就会发现所有的 a 和所有的 b 是可以转到一起的，故先转到一起，最后转到 a 在前 b 在后即可。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;char s[N];bool val[N];int main() &#123; scanf("%s", &amp;s); int n = strlen(s); char now = s[0]; for (int i = 0; i &lt; n; i++) &#123; if (s[i] != now) &#123; val[i-1] = 1; now = s[i]; &#125; &#125; if (now == 'a') val[n-1] = 1; for (int i = 0; i &lt; n; i++) &#123; printf("%d", val[i]); if (i == n-1) puts(""); else printf(" "); &#125;&#125; D. Mysterious Crime题意给定10个排列，问它们的相同子串的个数。 分析由于是排列，故每个数字唯一双射一个位置。 可直接按第一个串的子串找，相当于把第一个串分成好多段，每一段都是一个相同子串，由此计数。 具体分法，即某一段是否在某个位置结束，只用看第一段这个位置和其他串的对应位置是否映射同一个数字。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;int a[11][N], pos[11][N];bool vis[N];bool check(int x, int cnt) &#123; for (int i = 1; i &lt;= m; i++) if (pos[i][x]+cnt &gt; n) return 0; for (int i = 2; i &lt;= m; i++) if (a[i][pos[i][x]+cnt] != a[i-1][pos[i-1][x]+cnt]) return 0; return 1;&#125;int main() &#123; scanf("%d%d",&amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); pos[i][a[i][j]] = j; &#125; if (m == 1) &#123; printf("%lld\n",1ll*n*(n+1)/2); return 0; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; while(check(a[1][i], cnt)) cnt++; ans += 1ll*cnt*(cnt+1)/2; i += cnt-1; &#125; printf("%lld\n", ans);&#125; D - Crossing题意给定 n 个 (x,y) ，两两匹配的贡献是\(min(a_x+b_y,a_y+b_x)\) 然后除掉给定的m对匹配后，问你剩余的两两匹配之和。 分析按 \(a_x+b_y&lt;a_y+b_x\) 即 \(a_x-a_y&lt;b_x-b_y\) 排序后直接算即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;int n, m;struct Node &#123; int x, y, id; bool operator &lt; (const Node b) const &#123; return x-y &lt; b.x-b.y; &#125;&#125;a[N];ll x[N], y[N];ll ans[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); int res = min(a[u].x+a[v].y, a[u].y+a[v].x); ans[u] -= res; ans[v] -= res; &#125; sort(a+1, a+1+n); for (int i = 1; i &lt;= n; i++) x[i] = x[i-1] + a[i].x; for (int i = n; i &gt;= 1; i--) y[i] = y[i+1] + a[i].y; for (int i = 1; i &lt;= n; i++) &#123; ans[a[i].id] += 1ll*a[i].y*(i-1)+x[i-1]; ans[a[i].id] += 1ll*a[i].x*(n-i)+y[i+1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Make It One题意从 n(3e5) 个给定的数字中选一组 gcd 为 1 的数，最少选几个 分析根据唯一分解定理，每选择一个数字至少消去一种素因子，而前 7 个素因子之积已超过 3e5，故至多选7个。 \(dp[i][j]\) 表示 i 的倍数中选出 j 个，且 gcd 为 i 的方案数 ： dp[i][j] = \binom{cnt_i}{j}-\sum_{k=2}^{\infty}dp[i*k][j]1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const int MOD = 1e9+7;int F[N], Finv[N], inv[N];void init() &#123; inv[1] = 1; for (int i = 2; i &lt; N; i ++) &#123; inv[i] = (MOD - MOD / i) * 1ll * inv[MOD % i] % MOD; &#125; F[0] = Finv[0] = 1; for (int i = 1; i &lt; N; i ++) &#123; F[i] = F[i-1] * 1ll * i % MOD; Finv[i] = Finv[i-1] * 1ll * inv[i] % MOD; &#125;&#125;int comb(int n, int m) &#123; if (m &lt; 0 || m &gt; n) return 0; return F[n] * 1ll * Finv[n - m] % MOD * Finv[m] % MOD;&#125;int n, cnt[N];ll dp[N][10];int main() &#123; init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt[x]++; &#125; for (int i = 1; i &lt; N; i++) for (int j = i+i; j &lt; N; j += i) cnt[i] += cnt[j]; for (int i = N-1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= 7; j++) &#123; dp[i][j] = comb(cnt[i], j); for (int k = i+i; k &lt; N; k += i) dp[i][j] = (dp[i][j] + MOD - dp[k][j]) % MOD; &#125; &#125; int ans = -1; for (int i = 7; i &gt;= 1; i--) if (dp[1][i]) ans = i; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest (C,D,E)]]></title>
    <url>%2F2018%2F10%2F28%2FTenka1-Programmer-Contest%2F</url>
    <content type="text"><![CDATA[第一把 AtCoder，可以说是真的菜了，E 题调到死都没调出来… 地址 C - Align题意给定 n 个数字，要求排成一排后任意两个数字之差的绝对值之和最大，求最大值 分析一定是将数列排序后分成两半，前一半和后一半交替排列。绝对值符号可以去掉，然后每个数字计算次数只跟其位置有关，最后分类讨论一下就好了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+1+n); if (n%2 == 0) &#123; ll ans = 0; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; ans -= a[n/2]; ans += a[n/2+1]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; ll ans = 0; ans -= a[n/2]; ans -= a[n/2+1]; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; ll ans2 = 0; for (int i = 1; i &lt;= n/2; i++) ans2 -= 2*a[i]; ans2 += a[n/2+2]; ans2 += a[n/2+1]; for (int i = n/2+3; i &lt;= n; i++) ans2 += 2*a[i]; ans = max(ans, ans2); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D - Crossing题意给定 n，问是否存在这样的集合组： 1-n 每个数字都恰好被包含在两个集合中 任意两个集合仅有一个相同数字 分析n 条边的完全图 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n;int check(int n) &#123; for (int i = 1; i*(i-1)/2 &lt;= n; i++) if (i*(i-1)/2 == n) return i; return 0;&#125;int mp[505][505];int main() &#123; scanf("%d", &amp;n); int k = check(n); if (!k) puts("No"); else &#123; puts("Yes"); for (int i = 1; i &lt;= k; i++) for (int j = i+1; j &lt;= k; j++) mp[i][j] = mp[j][i] = n--; printf("%d\n", k); for (int i = 1; i &lt;= k; i++) &#123; printf("%d", k-1); for (int j = 1; j &lt;= k; j++) &#123; if (j == i) continue; printf(" %d", mp[i][j]); &#125; puts(""); &#125; &#125;&#125; E - Equilateral题意给出一张仅含 ‘#’ 和 ‘*’ 的矩阵，问位置三元组的数目，其满足每个位置上的字符都是 ‘#’ 且任意两点的麦哈顿距离相同 分析跟题解大致相同的思路。 中心红点是三点麦哈顿距离的交点。a 和 b 长度相同，第三个点坐落在蓝线上。故先枚举中间的红点，再枚举另外俩红点的位置，统计蓝线上的点的数目即可。预处理斜线前缀和，复杂度O(n^3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 305;int n, m;char mp[3*N][3*N];int suml[3*N][3*N], sumr[3*N][3*N];ll solve(int x, int y) &#123; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; if (mp[x-i][y] == '#') num++; if (mp[x+i][y] == '#') num++; if (mp[x][y-i] == '#') num++; if (mp[x][y+i] == '#') num++; if (num == 3) ans++; else if (num == 4) ans += 4; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x+1, sy = y+i-1; int ex = x+i-1, ey = y+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x+1, sy = y-i+1; int ex = x+i-1, ey = y-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x-i+1, sy = y-1; int ex = x-1, ey = y-i+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x-i+1, sy = y+1; int ex = x-1, ey = y+i-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = N+1; i &lt;= N+n; i++) scanf("%s", mp[i]+1+N); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) suml[i][j] = sumr[i][j] = (mp[i][j] == '#'); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) &#123; sumr[i][j] += sumr[i-1][j-1]; suml[i][j] += suml[i-1][j+1]; &#125; ll ans = 0; for (int i = N+1; i &lt;= N+n; i++) for (int j = N+1; j &lt;= N+m; j++) ans += solve(i, j); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
