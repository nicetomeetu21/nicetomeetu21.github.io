<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #520 (Div. 2)（A-E）]]></title>
    <url>%2F2018%2F11%2F18%2FCodeforces-Round-520-Div-2%2F</url>
    <content type="text"><![CDATA[感觉数学题略多. F 题解太长了..告辞.. 地址 A. Minimizing the String水签到。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); a[0] = 0, a[n+1] = 1001; int cnt = 1, ans = 0; for (int i = 1; i &lt;= n+1; i++) &#123; if (a[i] == a[i-1]+1) cnt++; else ans = max(ans, cnt-2), cnt = 1; &#125; ans = max(ans, cnt-2); cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Math题意给你一个数字 n，两个操作：乘上任意一个数；开根号（要求是平方数） 问最小能得到的数字是多少，至少几次操作 分析先上唯一分解定理，最小能得到的数字一定是 n 的所有质因子乘积。 最小次数可按每个质因子分开讨论，因为开根号即为质因子个数除以 2，故先把质因子个数加成二的幂再不断除。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;bool notp[N];int prime[N], pnum;void sieve() &#123; memset(notp, 0, sizeof(notp)); notp[0] = notp[1] = 1; pnum = 0; for (int i = 2; i &lt; N; i++) &#123; if (notp[i] == 0) prime[++pnum] = i; for (int j = 1; j &lt;= pnum &amp;&amp; prime[j] * i &lt; N; j++) &#123; notp[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int n;int main() &#123; sieve(); scanf("%d", &amp;n); int m = n; bool f = 0; int ans1 = 1, ans2 = 0, tmp = 0; for (int i = 1; i &lt;= pnum; i++) &#123; if (m % prime[i] == 0) &#123; int cnt = 0; while (m%prime[i] == 0) cnt++, m /= prime[i]; ans1 *= prime[i]; if (tmp &amp;&amp; cnt != tmp) f = 1; tmp = max(tmp, cnt); &#125; &#125; if (ans1 == n) &#123; printf("%d 0\n", ans1); &#125; else &#123; int x = 1; while (x &lt; tmp) x *= 2, ans2++; if (f || x != tmp) ans2++; printf("%d %d\n", ans1, ans2); &#125;&#125; C. Banh-mi题意先给你一个01串，有 q 个区间询问 操作是先在区间内选一个位置，然后把它吃掉，得到那个位置的得分，并且区间内剩余位置的得分全部加上那个位置的得分 每次询问问该区间所能得到的最大的分是多少 分析先吃大的再吃小的最优，由于只有 0 和 1 ，就先吃 1 再吃 0 每个位置对答案的贡献可单独计算，即 1011 可看作 1000：1+1+2+4 = 2^3 100：1+1+2 = 2^2 10：1+1 = 2^1 这是第一组样例，所以很明白了。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;const int MOD = 1e9+7;ll pw2[N];int n, q, sum[N];char s[N];int main() &#123; scanf("%d%d%s", &amp;n, &amp;q, s+1); pw2[0] = 1; for (int i = 1; i &lt;= n; i++) pw2[i] = pw2[i-1]*2%MOD; for (int i = 1; i &lt;= n; i++) pw2[i] = (pw2[i] + pw2[i-1]) % MOD; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i-1] + s[i]-'0'; while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = r-l+1, b = sum[r]-sum[l-1]; ll ans = pw2[a-1]; if (a &gt; b) ans = (ans + MOD - pw2[a-b-1]) % MOD; printf("%lld\n", ans); &#125;&#125; D. Fun with Integers题意绝对值小于 n 的数字（除了0，1，-1），让每个数字与其倍数（除去 -1）连边，边权是两者之商的绝对值，问每条边限走一遍能得到的最大权值和是多少 分析由于每个点度数都是偶数，故存在欧拉回路。所以每个连通分量里的每条边都能访问到。 实际上根据题解的证明（图中每条边都在同一个连通分量内）可以写出 这样 复杂度$O(\sqrt{n})$的代码。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int f[N];ll sum[N];int sf(int x) &#123; return x == f[x] ? x : f[x] = sf(f[x]);&#125;int n;int main() &#123; for (int i = 0; i &lt; N; i++) f[i] = i; scanf("%d", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; for (int j = i+i; j &lt;= n; j += i) &#123; f[sf(i)] = sf(j); sum[i] += 4*(j/i); &#125; &#125; for (int i = 1; i &lt;= n; i++) if (sf(i) != i) sum[sf(i)] += sum[i]; ll ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, sum[sf(i)]); printf("%lld\n", ans);&#125; E. Company题意给定一棵有根树，q 个区间询问。 对于每个询问，要求区间内删去一个点后剩余点的 LCA 的深度，问删哪个点，深度最大多少 分析没记错的话去年多校训练碰到过类似题目。 先对每个点求 DFS 序，由于所有点的 LCA 的 DFS 序的作用域一定是恰好包含所有点的 DFS 序，即这些点的 LCA 即为 DFS 序最小的和最大的两个点的 LCA 。 故删掉的一定是 DFS 序最小的点或者最大的点。 倍增求 LCA + ST 表，复杂度$O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define pw(i) (1&lt;&lt;(i))const int N = 1e5+5;const int LEV = 20;vector&lt;int&gt; G[N];int dph[N], fa[N][LEV];int L[N], dfs_clock, F[N]; // dfs序和逆映射void dfs(int rt, int f) &#123; L[rt] = ++dfs_clock; F[dfs_clock] = rt; for (int i = 1; i &lt; LEV; i++) &#123; if (dph[rt]-1 &lt; pw(i)) break; fa[rt][i] = fa[fa[rt][i-1]][i-1]; &#125; for (int v : G[rt]) &#123; dph[v] = dph[rt]+1; fa[v][0] = rt; dfs(v, rt); &#125;&#125;int lca(int a, int b) &#123; if (dph[a] &lt; dph[b]) swap(a, b); int t = dph[a]-dph[b]; for (int i = 0; i &lt; LEV; i++) if (pw(i)&amp;t) a = fa[a][i]; for (int i = LEV-1; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; if (a != b) return fa[a][0]; return a;&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); memset(fa, 0, sizeof(fa)); dph[1] = 1; dfs_clock = 0;&#125;int Min[N][20], Max[N][20], lg2[N];void Init(int a[], int n) &#123; for (int i = 2; i &lt;= n; i++) lg2[i] = lg2[i/2]+1; for (int i = 1; i &lt;= n; i++) Min[i][0] = Max[i][0] = a[i]; for (int j = 1; j &lt;= lg2[n]; j++) for (int i = 1; i+pw(j)-1 &lt;= n; i++) &#123; Min[i][j] = min(Min[i][j-1], Min[i+pw(j-1)][j-1]); Max[i][j] = max(Max[i][j-1], Max[i+pw(j-1)][j-1]); &#125;9&#125;int Qmin(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return min(Min[l][k], Min[r+1-pw(k)][k]);&#125;int Qmax(int l, int r) &#123; if (l &gt; r) swap(l, r); int k = lg2[r-l+1]; return max(Max[l][k], Max[r+1-pw(k)][k]);&#125;int solve(int l, int a, int r) &#123; if (a == l) return lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); if (a == r) return lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f1 = lca(F[Qmin(l, a-1)], F[Qmax(l, a-1)]); int f2 = lca(F[Qmin(a+1, r)], F[Qmax(a+1, r)]); return lca(f1, f2);&#125;int main() &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); init(n);//multiLCA-init for (int i = 2; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); G[x].push_back(i); &#125; dfs(1, 1); Init(L, n);//ST-init while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int a = F[Qmin(l, r)], b = F[Qmax(l, r)]; int fa = solve(l, a, r), fb = solve(l, b, r); if (dph[fa] &gt; dph[fb]) printf("%d %d\n", a, dph[fa]-1); else printf("%d %d\n", b, dph[fb]-1); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 54 (A-F)]]></title>
    <url>%2F2018%2F11%2F16%2FEducational-Codeforces-Round-54%2F</url>
    <content type="text"><![CDATA[日常掉分.. D 被无良学弟 hack 了，这个故事告诉我们 CF 上不要写spfa… E 比赛时候觉得挺难的（然后溜了），赛后仔细分析了下觉得还是挺妙的。 F 傻傻分析不清，然而题解分析的贼清楚.. 最后一题日常不会.. 地址 A. Minimizing the String题意删除一个字符使得字典序最小 分析贪心呀，从前往后删第一个 s[i]&gt;s[i-1]。或者最后一个。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5+5;char s[N];int n;int main() &#123; cin &gt;&gt; n &gt;&gt; s; int ans = n-1; for (int i = 0; i &lt; n-1; i++) &#123; if (s[i] &gt; s[i+1]) &#123; ans = i; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i == ans) continue; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl;&#125; B. Divisor Subtraction题意给一个数字 n，每次减去其最小质因子，重复此步骤，问共几次减到 0 分析如果 n 是质数，就一次。 如果 n 是偶数，就 n/2。 如果 n 是奇数，最小质因子 d 一定是奇数，故 (n-d)/2+1 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;ll n;ll solve(ll n) &#123; if (n%2 == 0) return n/2; for (ll i = 2; i*i &lt;= n; i++) if (n%i == 0) return 1+(n-i)/2; return 1;&#125;int main() &#123; cin &gt;&gt; n; cout &lt;&lt; solve(n) &lt;&lt; endl;&#125; C. Meme Problem解一元二次方程 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+5;typedef long long ll;int t, d;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;d); if (d*d-4*d &lt; 0) puts("N"); else &#123; double a = (d+sqrt(d*d-4*d))/2; double b = (d-sqrt(d*d-4*d))/2; printf("Y %.9f %.9f\n", a, b); &#125; &#125;&#125; D. Edge Deletion题意给你一张图，有边权。问你最多留下哪 k 条边，使得原图和新图中由 1 的最短路长度不变的点留下的最多 分析先建由 1 出发的最短路树，把多余的边全删掉。 还不够的话，从叶子开始删边。（拓扑排序或者别的什么） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const ll INF = 1e18;struct Edge &#123; int v; ll w; int id; bool operator &lt; (const Edge&amp; b) const &#123; return w &gt; b.w; &#125;&#125;;vector&lt;Edge&gt; G[N];void addedge(int u, int v, int w, int id) &#123; G[u].push_back(Edge&#123;v, w, id&#125;);&#125;int pre[N], f[N];ll d[N];bool vis[N];typedef Edge Node;priority_queue&lt;Node&gt; Q;void Dijkstra(int s, int n) &#123; while (!Q.empty()) Q.pop(); for (int i = 0; i &lt;= n; i++) d[i] = INF, vis[i] = 0; d[s] = 0; Q.push(Node&#123;s, 0&#125;); while (!Q.empty()) &#123; Node tmp = Q.top(); Q.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = 1; for (const auto&amp; e : G[u]) &#123; if (!vis[e.v] &amp;&amp; d[e.v] &gt; d[u] + e.w) &#123; d[e.v] = d[u] + e.w; pre[e.v] = e.id; f[e.v] = u; Q.push(Node&#123;e.v, d[e.v]&#125;); &#125; &#125; &#125;&#125;int n, m, k;int cnt[N];bool val[N];queue&lt;int&gt; que;void solve() &#123; for (int i = 2; i &lt;= n; i++) cnt[f[i]]++; for (int i = 1; i &lt;= n; i++) &#123; if (!cnt[i]) que.push(i); &#125; while (!que.empty()) &#123; int v = que.front(); que.pop(); val[pre[v]] = 0; k++; if (k == 0) return; cnt[f[v]]--; if (!cnt[f[v]]) que.push(f[v]); &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; Dijkstra(1, n); for (int i = 2; i &lt;= n; i++) val[pre[i]] = 1; for (int i = 1; i &lt;= m; i++) &#123; if (val[i]) k--; &#125; if (k &lt; 0) solve(); for (int i = 1; i &lt;= m; i++) if (val[i]) ans.push_back(i); printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; E. Vasya and a Tree题意给定一棵树和若干操作。操作 (v,d,x) 是 v 的子树中与 v 距离小于等于 d 的节点权值都加上 x 问所有操作结束后的每个点的权值。 分析操作可离线。建一棵基于深度的线段树（或者树状数组），在 DFS 不断修改和查询。 单次修改相当于 区间 [dps(v), dps(v)+d] 加上 x 。 区间修改单点查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 #include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int N = 3e5+5;vector&lt;int&gt; G[N];vector&lt;pii&gt; Q[N];ll c[N];void modify(int x, int num) &#123; while (x &lt; N) c[x] += num, x += x&amp;-x;&#125;ll sum(int x) &#123; ll s = 0; while (x) s += c[x], x -= x&amp;-x; return s;&#125;ll ans[N];int dps[N];void DFS(int u, int pre) &#123; dps[u] = dps[pre]+1; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u], x); modify(dps[u]+d+1, -x); &#125; ans[u] = sum(dps[u]); for (auto v : G[u]) &#123; if (v == pre) continue; DFS(v, u); &#125; for (auto p : Q[u]) &#123; int d = p.first, x = p.second; modify(dps[u],-x); modify(dps[u]+d+1, x); &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); G[a].push_back(b); G[b].push_back(a); &#125; int q; scanf("%d", &amp;q); while (q--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); Q[a].push_back(pii(b, c)); &#125; DFS(1, 1); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Summer Practice Report题意魔改题意。有 n 个连续的区间，告诉你每个区间里需要放\(x_i\)个物体 a，(y_i\)个物体 b 问你是否有一种放置方法，能不出现连续 k 个以上的 a 或 b（可跨区间）。 分析设 \(dp[i][0]\) 表示第 i 个区间， 若以 a 物体结尾，末尾最少的 a 物体数量。\(dp[i][1]\)类似。 最后判断 \(dp[n][0]\) 或 \(dp[n][1]\) 是否满足要求即可。 考虑 \(dp[i-1][0]\)转移至\(dp[i][0]\)： ​ 首先要满足 \(x_i \ge \lceil\frac{y_i}{k}\rceil\)，即每 k 个 b 物体后插入一个 a 。 ​ 然后当 \(x_i \le y_i*k+1 - dp[i-1][0] \) 时，某尾 a 的数量始终为 1，即每个 b 前面插满 k 个 a ，包括上一段的。 ​ \(x_i\)还多的话，则最少为 \(x_i-(y_i*k-dp[i-1][0])\)。 可同理考虑\(dp[i-1][1]\)转移至\(dp[i][0]\)，以及\(dp[i][1]\)的转移。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5+5;int n, k;int x[N], y[N];int dp[N][2];int solve1(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y+pre-1)/k+1) return k+1; if (x &lt;= 1ll*y*k) return 1; return x-1ll*y*k;&#125;int solve2(int pre, int x, int y) &#123; if (pre &gt; k) return k+1; if (x &lt; (y-1)/k+1) return k+1; if (x &lt;= 1ll*y*k-pre) return 1; return x-(1ll*y*k-pre);&#125;bool solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = min(solve1(dp[i-1][1], x[i], y[i]), solve2(dp[i-1][0], x[i], y[i])); dp[i][1] = min(solve1(dp[i-1][0], y[i], x[i]), solve2(dp[i-1][1], y[i], x[i])); &#125; return dp[n][0] &lt;= k || dp[n][1] &lt;= k;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;y[i]); if (solve()) puts("YES"); else puts("NO");&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #519 (A-F)]]></title>
    <url>%2F2018%2F11%2F13%2FCodeforces-Round-519-A-F%2F</url>
    <content type="text"><![CDATA[水一把 CF，感觉全暴力而且代码量略少。 G 题不会..打扰了.. 地址 A. Elections公式解即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, a[N];int main() &#123; scanf("%d", &amp;n); int s = 0, k = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); s += a[i]; k = max(k, a[i]); &#125; k = max(k, s*2/n+1); printf("%d\n", k);&#125; B. Lost ArrayKMP 的 next 函数求出所有循环节。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int n, a[N], nxt[N];void GetNxt(int s[], int n) &#123; int j = 0, k = -1; nxt[0] = -1; while(j &lt; n) &#123; if (k != -1 &amp;&amp; s[j] != s[k]) k = nxt[k]; else nxt[++j] = ++k; &#125;&#125;vector&lt;int&gt; ans;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = n; i &gt;= 1; i--) a[i] -= a[i-1]; GetNxt(a+1, n); int m = n; while (nxt[m] &gt;= 0) &#123; ans.push_back(n-nxt[m]); m = nxt[m]; &#125; printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d", ans[i]); if (i == ans.size()-1) puts(""); else printf(" "); &#125;&#125; C. Smallest Word题意给定一个只有字符 a,b 的串，问按顺序 reverse 哪几个前缀可以使其字典序最小。 分析转几次就会发现所有的 a 和所有的 b 是可以转到一起的，故先转到一起，最后转到 a 在前 b 在后即可。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;char s[N];bool val[N];int main() &#123; scanf("%s", &amp;s); int n = strlen(s); char now = s[0]; for (int i = 0; i &lt; n; i++) &#123; if (s[i] != now) &#123; val[i-1] = 1; now = s[i]; &#125; &#125; if (now == 'a') val[n-1] = 1; for (int i = 0; i &lt; n; i++) &#123; printf("%d", val[i]); if (i == n-1) puts(""); else printf(" "); &#125;&#125; D. Mysterious Crime题意给定10个排列，问它们的相同子串的个数。 分析由于是排列，故每个数字唯一双射一个位置。 可直接按第一个串的子串找，相当于把第一个串分成好多段，每一段都是一个相同子串，由此计数。 具体分法，即某一段是否在某个位置结束，只用看第一段这个位置和其他串的对应位置是否映射同一个数字。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, m;int a[11][N], pos[11][N];bool vis[N];bool check(int x, int cnt) &#123; for (int i = 1; i &lt;= m; i++) if (pos[i][x]+cnt &gt; n) return 0; for (int i = 2; i &lt;= m; i++) if (a[i][pos[i][x]+cnt] != a[i-1][pos[i-1][x]+cnt]) return 0; return 1;&#125;int main() &#123; scanf("%d%d",&amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); pos[i][a[i][j]] = j; &#125; if (m == 1) &#123; printf("%lld\n",1ll*n*(n+1)/2); return 0; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; while(check(a[1][i], cnt)) cnt++; ans += 1ll*cnt*(cnt+1)/2; i += cnt-1; &#125; printf("%lld\n", ans);&#125; D - Crossing题意给定 n 个 (x,y) ，两两匹配的贡献是\(min(a_x+b_y,a_y+b_x)\) 然后除掉给定的m对匹配后，问你剩余的两两匹配之和。 分析按 \(a_x+b_y&lt;a_y+b_x\) 即 \(a_x-a_y&lt;b_x-b_y\) 排序后直接算即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;int n, m;struct Node &#123; int x, y, id; bool operator &lt; (const Node b) const &#123; return x-y &lt; b.x-b.y; &#125;&#125;a[N];ll x[N], y[N];ll ans[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].x, &amp;a[i].y); a[i].id = i; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); int res = min(a[u].x+a[v].y, a[u].y+a[v].x); ans[u] -= res; ans[v] -= res; &#125; sort(a+1, a+1+n); for (int i = 1; i &lt;= n; i++) x[i] = x[i-1] + a[i].x; for (int i = n; i &gt;= 1; i--) y[i] = y[i+1] + a[i].y; for (int i = 1; i &lt;= n; i++) &#123; ans[a[i].id] += 1ll*a[i].y*(i-1)+x[i-1]; ans[a[i].id] += 1ll*a[i].x*(n-i)+y[i+1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%lld", ans[i]); if (i == n) puts(""); else printf(" "); &#125;&#125; F. Make It One题意从 n(3e5) 个给定的数字中选一组 gcd 为 1 的数，最少选几个 分析根据唯一分解定理，每选择一个数字至少消去一种素因子，而前 7 个素因子之积已超过 3e5，故至多选7个。 \(dp[i][j]\) 表示 i 的倍数中选出 j 个，且 gcd 为 i 的方案数 ： dp[i][j] = \binom{cnt_i}{j}-\sum_{k=2}^{\infty}dp[i*k][j]1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3e5+5;const int MOD = 1e9+7;int F[N], Finv[N], inv[N];void init() &#123; inv[1] = 1; for (int i = 2; i &lt; N; i ++) &#123; inv[i] = (MOD - MOD / i) * 1ll * inv[MOD % i] % MOD; &#125; F[0] = Finv[0] = 1; for (int i = 1; i &lt; N; i ++) &#123; F[i] = F[i-1] * 1ll * i % MOD; Finv[i] = Finv[i-1] * 1ll * inv[i] % MOD; &#125;&#125;int comb(int n, int m) &#123; if (m &lt; 0 || m &gt; n) return 0; return F[n] * 1ll * Finv[n - m] % MOD * Finv[m] % MOD;&#125;int n, cnt[N];ll dp[N][10];int main() &#123; init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); cnt[x]++; &#125; for (int i = 1; i &lt; N; i++) for (int j = i+i; j &lt; N; j += i) cnt[i] += cnt[j]; for (int i = N-1; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= 7; j++) &#123; dp[i][j] = comb(cnt[i], j); for (int k = i+i; k &lt; N; k += i) dp[i][j] = (dp[i][j] + MOD - dp[k][j]) % MOD; &#125; &#125; int ans = -1; for (int i = 7; i &gt;= 1; i--) if (dp[1][i]) ans = i; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tenka1 Programmer Contest (C,D,E)]]></title>
    <url>%2F2018%2F10%2F28%2FTenka1-Programmer-Contest%2F</url>
    <content type="text"><![CDATA[第一把 AtCoder，可以说是真的菜了，E 题调到死都没调出来… 地址 C - Align题意给定 n 个数字，要求排成一排后任意两个数字之差的绝对值之和最大，求最大值 分析一定是将数列排序后分成两半，前一半和后一半交替排列。绝对值符号可以去掉，然后每个数字计算次数只跟其位置有关，最后分类讨论一下就好了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5+5;int n, a[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); sort(a+1, a+1+n); if (n%2 == 0) &#123; ll ans = 0; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; ans -= a[n/2]; ans += a[n/2+1]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; ll ans = 0; ans -= a[n/2]; ans -= a[n/2+1]; for (int i = 1; i &lt; n/2; i++) ans -= 2*a[i]; for (int i = n/2+2; i &lt;= n; i++) ans += 2*a[i]; ll ans2 = 0; for (int i = 1; i &lt;= n/2; i++) ans2 -= 2*a[i]; ans2 += a[n/2+2]; ans2 += a[n/2+1]; for (int i = n/2+3; i &lt;= n; i++) ans2 += 2*a[i]; ans = max(ans, ans2); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; D - Crossing题意给定 n，问是否存在这样的集合组： 1-n 每个数字都恰好被包含在两个集合中 任意两个集合仅有一个相同数字 分析n 条边的完全图 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n;int check(int n) &#123; for (int i = 1; i*(i-1)/2 &lt;= n; i++) if (i*(i-1)/2 == n) return i; return 0;&#125;int mp[505][505];int main() &#123; scanf("%d", &amp;n); int k = check(n); if (!k) puts("No"); else &#123; puts("Yes"); for (int i = 1; i &lt;= k; i++) for (int j = i+1; j &lt;= k; j++) mp[i][j] = mp[j][i] = n--; printf("%d\n", k); for (int i = 1; i &lt;= k; i++) &#123; printf("%d", k-1); for (int j = 1; j &lt;= k; j++) &#123; if (j == i) continue; printf(" %d", mp[i][j]); &#125; puts(""); &#125; &#125;&#125; E - Equilateral题意给出一张仅含 ‘#’ 和 ‘*’ 的矩阵，问位置三元组的数目，其满足每个位置上的字符都是 ‘#’ 且任意两点的麦哈顿距离相同 分析跟题解大致相同的思路。 中心红点是三点麦哈顿距离的交点。a 和 b 长度相同，第三个点坐落在蓝线上。故先枚举中间的红点，再枚举另外俩红点的位置，统计蓝线上的点的数目即可。预处理斜线前缀和，复杂度O(n^3) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 305;int n, m;char mp[3*N][3*N];int suml[3*N][3*N], sumr[3*N][3*N];ll solve(int x, int y) &#123; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int num = 0; if (mp[x-i][y] == '#') num++; if (mp[x+i][y] == '#') num++; if (mp[x][y-i] == '#') num++; if (mp[x][y+i] == '#') num++; if (num == 3) ans++; else if (num == 4) ans += 4; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x+1, sy = y+i-1; int ex = x+i-1, ey = y+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x-i &gt;= N+1 &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x-i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x+1, sy = y-i+1; int ex = x+i-1, ey = y-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y+i &lt;= N+m; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y+i] == '.') continue; int sx = x-i+1, sy = y-1; int ex = x-1, ey = y-i+1; ans += suml[ex][ey] - suml[sx-1][sy+1]; &#125; for (int i = 2; x+i &lt;= N+n &amp;&amp; y-i &gt;= N+1; i++) &#123; if (mp[x+i][y] == '.' || mp[x][y-i] == '.') continue; int sx = x-i+1, sy = y+1; int ex = x-1, ey = y+i-1; ans += sumr[ex][ey] - sumr[sx-1][sy-1]; &#125; return ans;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = N+1; i &lt;= N+n; i++) scanf("%s", mp[i]+1+N); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) suml[i][j] = sumr[i][j] = (mp[i][j] == '#'); for (int i = 1; i &lt;= 2*N+n; i++) for (int j = 1; j &lt;= 2*N+m; j++) &#123; sumr[i][j] += sumr[i-1][j-1]; suml[i][j] += suml[i-1][j+1]; &#125; ll ans = 0; for (int i = N+1; i &lt;= N+n; i++) for (int j = N+1; j &lt;= N+m; j++) ans += solve(i, j); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
</search>
